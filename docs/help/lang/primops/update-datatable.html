<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><tt>R←{X}2010⌶Y</tt>Update DataTable</h2><p>This function performs a <span class="Italic">block update</span> of an instance of the ADO.NET object System.Data.DataTable. This object may only be updated using an explicit row-wise loop, which is slow at the APL level. <tt>2010⌶</tt> implements an <span class="Italic">internal</span> row-wise loop which is much faster on large arrays. Furthermore, the function handles NULL values and the conversion of internal APL data to the appropriate .Net datatype in a more efficient manner than can be otherwise achieved. These 3 factors together mean that the function provides a significant improvement in performance compared to calling the row-wise programming interface directly at the APL level.</p><p><tt>Y</tt> is a 2, 3 or 4-item array containing <tt>dtRef</tt>, <tt>Data</tt>, <tt>NullValues</tt> and <tt>Rows</tt> as described in the table below.</p><p>The optional argument <tt>X</tt> is the Boolean vector <tt>ParseFlags</tt> as described in the table below.</p><table><tr><th class="Left">Argument</th><th class="Left">Description</th></tr><tr><td><tt>dtRef</tt></td><td>A reference to an instance of System.Data.DataTable.</td></tr><tr><td><tt>Data</tt></td><td>A matrix with the same number of columns as the table.</td></tr><tr><td><tt>NullValues</tt></td><td>An optional vector with one element per column, containing the value which should be mapped to DBNull when this column is written to the DataTable.</td></tr><tr><td><tt>Rows</tt></td><td>Row indices (zero origin) of the rows to be updated. If not provided, data will be appended to the DataTable.</td></tr><tr><td><tt>ParseFlags</tt></td><td>A Boolean vector, where a 1 indicates that the corresponding element of Data is a string which needs to be passed to the Parse method of the data type of column in question.</td></tr></table><h4>Example</h4><p>Shown firstly for comparison is the type of code that is required to update a DataTable by looping:</p><pre>      ⎕USING←'System' 'System.Data,system.data.dll'
      dt←⎕NEW DataTable
      ac←{dt.Columns.Add ⍺ ⍵}
      'S1' 'S2' 'I1' 'D1' ac¨String String Int32 DateTime
 S1  S2  I1  D1
 
      NextYear←DateTime.Now+{⎕NEW TimeSpan (4↑⍵)}¨⍳n←365
      data←(⍕¨⍳n),(n⍴'odd' 'even'),(10|⍳n),⍪NextYear
      ¯2 4↑data
 364  even  4  18-01-2011 14:03:29 
 365  odd   5  19-01-2011 14:03:29 
 
      ar←{(row←dt.NewRow).ItemArray←⍵ ⋄ dt.Rows.Add row}
      t←3⊃⎕ai ⋄ ar¨↓data ⋄ (3⊃⎕ai)-t
449</pre><p>This result shows that this code can only insert roughly 100 rows per second (<tt>3⊃⎕AI</tt> returns elapsed time in milliseconds), because of the need to loop on each row and perform a noticeable amount of work each time around the loop.</p><p><tt>2010⌶</tt> does all the looping in compiled code:</p><pre>      dt.Rows.Clear ⍝ Delete the rows inserted above
      SetDT←2010⌶
      t←3⊃⎕AI ⋄ SetDT dt data ⋄ (3⊃⎕AI)-t4</pre><p>So in this case, using <tt>2010⌶</tt> achieves something like 10,000 rows per second.</p><h4>Using ParseFlags</h4><p>Sometimes it is more convenient to handle .Net datatypes in the workspace as strings rather than as the appropriate APL array equivalent. The System.DateTime datatype (which by default is represented in the workspace as a 6-element numeric vector) is one such example. <tt>2010⌶</tt> will accept such character data and convert it to the appropriate .Net datatype internally.</p><p>If specified, the optional left argument <tt>X(ParseFlags)</tt> instructs the system to pass the corresponding columns of Data to the Parse() method of the data type in question prior to performing the update.</p><p class="pagebreakafter"> </p><pre>      NextYear←⍕¨DateTime.Now+{⎕NEW TimeSpan (4↑⍵)}¨⍳n←365
 
      data←(⍕¨⍳n),(n⍴'odd' 'even'),(10|⍳n),NextYear
      ¯2 4↑data
 364  even  4  18-01-2011 14:03:29 
 365  odd   5  19-01-2011 14:03:29 
 
      SetDT←2010⌶      0 0 0 1 SetDT dt data</pre><h4>Handling Nulls</h4><p>If applicable, <tt>NullValues</tt> is a vector with as many elements as the DataTable has columns, indicating the value that should be converted to <tt>System.DBNull</tt> as data is written. For example, using the same DataTable as above:</p><pre>      t
 &lt;null&gt;  odd    1  21-01-2010 14:50:19 
 two     even   2  22-01-2010 14:50:19 
 three   odd   99  23-01-2010 14:50:19
 
      dt.Rows.Clear ⍝ Clear the contents of dt
      SetDT dt t ('&lt;null&gt;' 'even' 99 '')</pre><p>Above, we have declares that the string <tt>'&lt;null&gt;'</tt> should be considered to be a null value in the first column, <tt>'even'</tt> in the second column, and the integer <tt>99</tt> in the third.</p><h4>Updating Selected Rows</h4><p>Sometimes, you may have read a very large number of rows from a DataTable, but only want to update a single row, or a very small number of rows. Row indices can be provided as the fourth element of the argument to <tt>2010⌶</tt>. If you are not using <tt>NullValues</tt>, you can just use an empty vector as a placeholder. Continuing from the example above, we could replace the first row in our DataTable using:</p><pre>      SetDT←2010⌶
      SetDT dt (1 4⍴'one' 'odd' 1 DateTime.Now) ⍬ 0</pre><p>Note</p><ul><li value="1">the values must be provided as a matrix, even if you only want to update a single row, </li><li value="2">row indices are zero origin (the first row has number 0).</li></ul><h4>Warning</h4><p>If you are experimenting with writing to a DataTable, note that you should call dt.Rows.Clear each time to clear the current contents of the table. Otherwise you will end up with a very large number of rows after a while.</p><script src="../../../help.js"></script></body>
</html>