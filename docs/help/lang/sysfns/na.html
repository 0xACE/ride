<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><tt>{R}←{X}⎕NA Y</tt>Name Association </h2><p><tt>⎕NA</tt> provides access from APL to compiled functions within a <b>Dynamic Link Library </b>(<b>DLL</b>). A DLL is a collection of functions typically written in C (or C++) each of which may take arguments and return a result.</p><p>Instructional examples using <tt>⎕NA</tt> can be found in supplied workspace: <tt>QUADNA.DWS</tt>.</p><p>The DLL may be part of the standard operating system software, purchased from a third party supplier, or one that you have written yourself.</p><p>The right argument <tt>Y</tt> is a character vector that identifies the name and syntax of the function to be associated. The left argument <tt>X</tt> is a character vector that contains the name to be associated with the external function. If the <tt>⎕NA</tt> is successful, a function (name class 3) is established in the active workspace with name <tt>X</tt>. If <tt>X</tt> is omitted, the name of the external function itself is used for the association.</p><p>The shy result <tt>R</tt> is a character vector containing the name of the external function that was fixed. </p><p>For example, <span class="Code">math.dll</span> might be a library of mathematical functions containing a function <span class="Code">divide</span>. To associate the APL name <tt>div</tt> with this external function:</p><pre>      'div' ⎕NA 'F8 math|divide I4 I4'</pre><p>where <tt>F8</tt> and <tt>I</tt>4, specify the types of the result and arguments expected by <span class="Code">divide</span>. The association has the effect of establishing a new function: <tt>div</tt> in the workspace, which when called, passes its arguments to <span class="Code">divide</span> and returns the result.</p><pre>      )fns
div
      div 10 4
2.5</pre><h4>Type Declaration</h4><p>In a compiled language such as C, the types of arguments and results of functions must be declared explicitly. Typically, these types will be published with the documentation that accompanies the DLL. For example, function <span class="Code">divide</span> might be declared:</p><p><span class="Code">double divide(int32_t, int32_t);</span></p><p>which means that it expects two long (4-byte) integer arguments and returns a double (8-byte) floating point result. Notice the correspondence between the C declaration and the right argument of <tt>⎕NA</tt>:</p><pre class="Code">C:             double    divide       (int32_t,  int32_t);</pre><pre class="APLCodeSmall">APL:'div' ⎕NA 'F8   math|divide        I4        I4 '</pre><p>It is imperative that care be taken when coding type declarations. A DLL <span class="Italic">cannot</span> check types of data passed from APL. A wrong type declaration will lead to erroneous results or may even cause the workspace to become corrupted and crash.</p><p>The full syntax for the right argument of <tt>⎕NA</tt> is:</p><p>[result] library|function [arg1] [arg2] ...</p><p>Note that functions associated with DLLs are never dyadic. All arguments are passed as items of a (possibly nested) vector on the right of the function. </p><h4>Locating the DLL</h4><p>The DLL may be specified using a full pathname, file extension, and function type.</p><h4>Pathname:</h4><p> APL uses the <span class="Code">LoadLibrary()</span> system function under Windows and <span class="Code">dlopen()</span> under UNIX and Linux to load the DLL. If a full or relative pathname is omitted, these functions search standard operating system directories in a particular order. For further details, see the operating system documentation about these functions.</p><p>Alternatively, a full or relative pathname may be supplied in the usual way:</p><pre>      ⎕NA'... c:\mydir\mydll|foo ...'</pre><h4>Errors:</h4><p> If the specified DLL (or a dependent DLL) fails to load it will generate:</p><pre>FILE ERROR 2 No such file or directory</pre><p>If the DLL loads successfully, but the specified library function is not accessible, it will generate:</p><pre>VALUE ERROR</pre><h4>File Extension:</h4><p>Under Windows, if the file extension is omitted, <b>.dll</b> is assumed. Note that some DLLs are in fact <b>.exe</b> files, and in this case the extension must be specified explicitly:</p><pre>      ⎕NA'... mydll.exe|foo ...'</pre><h4>Example</h4><pre>      ⎕NA'... mydll.exe.P32|foo ...'⍝ 32 bit Pascal</pre><h4>Name Mangling</h4><p>C++ and some other languages will by default mangle (or decorate) function names which are exported from a DLL file. The given external function name must exactly match the exported name, either by matching the name mangling or by ensuring the names exported from the library are not mangled.</p><h4>Call by Ordinal Number</h4><p>Under Windows, a DLL may associate an <span class="Italic">ordinal number</span> with any of its functions. This number may then be used to call the function as an alternative to calling it by name. Using <tt>⎕NA</tt> to call by ordinal number uses the same syntax but with the function name replaced with its ordinal number. For example:</p><pre>      ⎕NA'... mydll|57 ...'</pre><h4>Multi-Threading</h4><p>Appending the ‘<tt>&amp;</tt>’ character to the function name causes the external function to be run in its own system thread. For example:</p><pre>      ⎕NA'... mydll|foo&amp; ...'</pre><p>This means that other APL threads can run concurrently with the one that is calling the <tt>⎕NA</tt> function.</p><h4>Data Type Coding Scheme</h4><p>The type coding scheme introduced above is of the form:</p><p>[direction] [special] type [width] [array]</p><p>The options are summarised in the following table and their functions detailed below.</p><table><tr><th class="Left">Description</th><th class="Left">Symbol</th><th class="Left">Meaning</th></tr><tr><td rowspan="3">Direction</td><td><tt>&lt;</tt></td><td>Pointer to array <span class="Italic">input</span> to DLL function.</td></tr><tr><td><tt>&gt;</tt></td><td>Pointer to array <span class="Italic">output</span> from DLL function</td></tr><tr><td><tt>=</tt></td><td>Pointer to input/output array.</td></tr><tr><td rowspan="2">Special</td><td><tt>0</tt></td><td>Null-terminated string.</td></tr><tr><td><tt>#</tt></td><td>Byte-counted string</td></tr><tr><td rowspan="10">Type</td><td><tt>I</tt></td><td>int</td></tr><tr><td><tt>U</tt></td><td>unsigned int</td></tr><tr><td><tt>C</tt></td><td>char </td></tr><tr><td><tt>T</tt></td><td>char<span class="MCTextPopup"><span class="MCTextPopupBody_0" style="display: none; ">Classic Edition:  - translated to/from ANSI</span><a href="javascript:void(0);" class="MCTextPopupSpot_0" onclick="FMCTextPopup( event, this ); return false;" style="font-size: 0.9em; vertical-align: super">1</a></span></td></tr><tr><td><tt>F</tt></td><td>float</td></tr><tr><td><tt>D</tt></td><td>decimal</td></tr><tr><td><tt>J</tt></td><td>complex</td></tr><tr><td><tt>P</tt></td><td>uintptr-t<span class="MCTextPopup"><span class="MCTextPopupBody_0" style="display: none; "> equivalent to U4 on 32-bit versions and U8 on 64-bit versions</span><a href="javascript:void(0);" class="MCTextPopupSpot_0" onclick="FMCTextPopup( event, this ); return false;" style="font-size: 0.9em; vertical-align: super">2</a></span></td></tr><tr><td><tt>A</tt></td><td>APL array</td></tr><tr><td><tt>Z</tt></td><td>APL array with header (as passed to a TCP/IP socket)</td></tr><tr><td rowspan="5">Width</td><td><tt>1</tt></td><td>1-byte</td></tr><tr><td><tt>2</tt></td><td>2-byte</td></tr><tr><td><tt>4</tt></td><td>4-byte</td></tr><tr><td><tt>8</tt></td><td>8-byte</td></tr><tr><td><tt>16</tt></td><td>16-byte (128-bit)</td></tr><tr><td rowspan="2">Array</td><td><tt>[n]</tt></td><td>Array of length <span class="Italic">n</span> elements</td></tr><tr><td><tt>[]</tt></td><td>Array, length determined at call-time</td></tr><tr><td>Structure</td><td><tt>{...}</tt></td><td>Structure.</td></tr></table><p>In the Classic Edition, <tt>C</tt> specifies untranslated character, whereas <tt>T</tt> specifies that the character data will be translated to/from <tt>⎕AV</tt>.</p><p>In the Unicode Edition, C and T are identical (no translation of character data is performed) except that for C the default width is 1 and for T the default width is "wide" (2 bytes under Windows, 4 bytes under UNIX).</p><p>The use of T with default width is recommended to ensure portability between Editions.</p><h4>Direction</h4><p>C functions accept data arguments either by <span class="Italic">value</span> or by <span class="Italic">address</span>. This distinction is indicated by the presence of a ‘<span class="Code">*</span>’ or ‘<span class="Code">[]</span>’ in the argument declaration:</p><pre class="Code">int  num1;       // value of num1 passed.
int *num2;       // Address of num2 passed.
int num3[];      // Address of num3 passed.</pre><p>An argument (or result) of an external function of type pointer, must be matched in the <tt>⎕NA</tt> call by a declaration starting with one of the characters: <tt>&lt;</tt>, <tt>&gt;</tt>, or <tt>=</tt>.</p><p>In C, when an address is passed, the corresponding value can be used as either an <span class="Italic">input</span> or an <span class="Italic">output</span> variable. An output variable means that the C function overwrites values at the supplied address. Because APL is a call-by-value language, and doesn’t have pointer types, we accommodate this mechanism by distinguishing output variables, and having them returned explicitly as part of the result of the call.</p><p>This means that where the C function indicates a <span class="Italic">pointer type</span>, we must code this as starting with one of the characters: <tt>&lt;</tt>, <tt>&gt;</tt> or <tt>=</tt>.</p><table><tbody><tr><td class="DyalogPlain">&lt;</td><td> indicates that the address of the argument will be used by C as an input variable and values at the address will <span class="Italic">not</span> be over-written.</td></tr><tr><td class="DyalogPlain">&gt;</td><td> indicates that C will use the address as an output variable. In this case, APL must allocate an output array over which C can write values. After the call, this array will be included in the nested result of the call to the external function.</td></tr><tr><td class="DyalogPlain">=</td><td> indicates that C will use the address for both input and output. In this case, APL duplicates the argument array into an output buffer whose address is passed to the external function. As in the case of an output only array, the newly modified copy will be included in the nested result of the call to the external function.</td></tr></tbody></table><h4>Examples</h4><table><tbody><tr><td class="DyalogPlain">&lt;I2</td><td>Pointer to 2-byte integer - <span class="Italic">input</span> to external function</td></tr><tr><td class="DyalogPlain">&gt;C</td><td>Pointer to character <span class="Italic">output</span> from external function.</td></tr><tr><td class="DyalogPlain">=T</td><td>Pointer to character <span class="Italic">input</span> to and <span class="Italic">output</span> from function.</td></tr><tr><td class="DyalogPlain">=A</td><td>Pointer to APL array <span class="Italic">modified</span> by function.</td></tr></tbody></table><h4>Special</h4><p>In C it is common to represent character strings as <span class="Italic">null-terminated</span> or <span class="Italic">byte counted</span> arrays. These special data types are indicated by inserting the symbol <tt>0</tt> (null-terminated) or <tt>#</tt> (byte counted) between the direction indicator (<tt>&lt;</tt>, <tt>&gt;</tt>, <tt>=</tt>) and the type (<tt>T</tt> or <tt>C)</tt> specification. For example, a pointer to a null-terminated input character string is coded as <tt>&lt;0T[]</tt>, and an output one coded as <tt>&gt;0T[]</tt>.</p><p>Note that while appending the array specifier ‘<tt>[]</tt>’ is formally correct, because the presence of the special qualifier (<tt>0</tt> or <tt>#</tt>) <span class="Italic">implies</span> an array, the ‘<tt>[]</tt>’ may be omitted: <tt>&lt;0T</tt>, <tt>&gt;0T</tt>, <tt>=#C</tt>, etc.</p><p>Note also that the 0 and # specifiers may be used with data of all types (excluding <tt>A</tt> and <tt>Z</tt>) and widths. For example, in the Classic Edition, <tt>&lt;0U2</tt> may be useful for dealing with Unicode.</p><h4>Type</h4><p>The data type of the argument may be one of the following characters and  may be specified in lower or upper case: </p><table><tr><th class="Left"> </th><th class="Left">Type</th><th class="Left">Description</th></tr><tr><td><tt>I</tt></td><td>Integer</td><td>The value is interpreted as a 2s complement signed integer</td></tr><tr><td><tt>U</tt></td><td>Unsigned integer</td><td>The value is interpreted as an unsigned integer</td></tr><tr><td><tt>C</tt></td><td>Character</td><td>The value is interpreted as a character. In the Unicode Edition, the value maps directly onto a Unicode code point. In the Classic Edition, the value is interpreted as an index into <tt>⎕AV</tt>. This means that <tt>⎕AV</tt><span class="Italic">positions</span> map onto corresponding ANSI <span class="Italic">positions</span>.<br />For example, with <tt>⎕IO=0</tt>:<br /><tt>⎕AV[35] = 's'</tt>, maps to<span class="Code">ANSI[35] = ’</span></td></tr><tr><th class="Left"> </th><th class="Left">Type</th><th class="Left">Description</th></tr><tr><td><tt>T</tt></td><td>Translated character</td><td>The value is interpreted as a character. In the Unicode Edition, the value maps directly onto a Unicode code point. In the Classic Edition, the value is <span class="Italic">translated</span> using standard Dyalog <tt>⎕AV</tt> to ANSI translation. This means that <tt>⎕AV</tt><span class="Italic">characters</span> map onto corresponding ANSI <span class="Italic">characters.</span><br />For example, with <tt>⎕IO=0</tt>:<br /><tt>⎕AV[35] = 's'</tt>, maps to<span class="Code">ANSI[115] = ’s’</span></td></tr><tr><td><tt>F</tt></td><td>Float</td><td>The value is interpreted as an IEEE 754-2008 binary64 floating point number</td></tr><tr><td><tt>D</tt></td><td>Decimal</td><td>The value is interpreted as an IEEE 754-2008 decimal128 floating point number (DPD format)</td></tr><tr><td><tt>J</tt></td><td>Complex</td><td> </td></tr><tr><td><tt>P</tt></td><td>uintptr-t</td><td>This is equivalent to U4 on 32-bit versions and U8 on 64-bit versions</td></tr><tr><td><tt>Z</tt></td><td>APL array<br />with header</td><td>This is the same format as is used to transmit APL arrays over TCP/IP Sockets</td></tr></table><h4>Width</h4><p>The type specifier may be followed by the width of the value in bytes. For example:</p><table><tbody><tr><td class="DyalogPlain">I4</td><td>4-byte signed integer.</td></tr><tr><td class="DyalogPlain">U2</td><td>2-byte unsigned integer.</td></tr><tr><td class="DyalogPlain">F8</td><td>8-byte floating point number.</td></tr><tr><td class="DyalogPlain">F4</td><td>4-byte floating point number.</td></tr><tr><td class="DyalogPlain">D16</td><td>16-byte decimal floating-point number</td></tr></tbody></table><table><tr><th class="Left">Type</th><th class="Left">Possible values for Width</th><th class="Left">Default value for Width</th></tr><tr><td><tt>I</tt></td><td>1, 2, 4, 8</td><td>4</td></tr><tr><td><tt>U</tt></td><td>1, 2, 4, 8</td><td>4</td></tr><tr><td><tt>C</tt></td><td>1,2,4</td><td>1</td></tr><tr><td><tt>T</tt></td><td>1,2,4</td><td>wide character(see below)</td></tr><tr><td><tt>F</tt></td><td>4, 8</td><td>8</td></tr><tr><td><tt>D</tt></td><td>16</td><td>16</td></tr><tr><td><tt>J</tt></td><td>16</td><td>16</td></tr><tr><td><tt>P</tt></td><td>Not applicable</td><td> </td></tr><tr><td><tt>A</tt></td><td>Not applicable</td><td> </td></tr><tr><td><tt>Z</tt></td><td>Not applicable</td><td> </td></tr></table><p>In the Unicode Edition, the default width is the width of a <span class="Italic">wide character </span>according to the convention of the host operating system. This translates to T2 under Windows and T4 under UNIX or Linux.</p><p>Note that 32-bit versions can support 64-bit integer <span class="Italic">arguments</span>, but not 64-bit integer <span class="Italic">results</span>.</p><h4>Examples</h4><table><tbody><tr><td class="DyalogPlain">I2</td><td>16-bit integer</td></tr><tr><td class="DyalogPlain">&lt;I4</td><td>Pointer to input 4-byte integer</td></tr><tr><td class="DyalogPlain">U</td><td>Default width unsigned integer</td></tr><tr><td class="DyalogPlain">=F4</td><td>Pointer to input/output 4-byte floating point number.</td></tr></tbody></table><h4>Arrays</h4><p>Arrays are specified by following the basic data type with <tt>[n]</tt> or <tt>[]</tt>, where <tt>n</tt> indicates the number of elements in the array. In the C declaration, the number of elements in an array may be specified explicitly at compile time, or determined dynamically at runtime. In the latter case, the size of the array is often passed along with the array, in a separate argument. In this case, <tt>n</tt>, the number of elements is omitted from the specification. Note that C deals only in scalars and rank 1 (vector) arrays.</p><pre class="Code">int vec[10];               // explicit vector length.
unsigned size, list[];     // undetermined length. </pre><p>could be coded as:</p><table><tbody><tr><td class="DyalogPlain">I[10]</td><td>vector of 10 ints.</td></tr><tr><td class="DyalogPlain">U U[]</td><td>unsigned integer followed by an array of unsigned integers.</td></tr></tbody></table><p>Confusion sometimes arises over a difference in the declaration syntax between C and <tt>⎕NA</tt>. In C, an argument declaration may be given to receive a pointer to either a single scalar item, or to the first element of an array. This is because in C, the address of an array is deemed to be the address of its first element.</p><pre class="Code">   void foo (char *string);
   char ch = 'a', ptr = "abc";
   foo(&amp;ch);// call with address of scalar.
   foo(ptr);// call with address of array.</pre><p>However, from APL’s point of view, these two cases are distinct and if the function is to be called with the address of (pointer to) a <span class="Italic">scalar</span>, it must be declared: <tt>'&lt;T'</tt>. Otherwise, to be called with the address of an <span class="Italic">array</span>, it must be declared: <tt>'&lt;T[]'</tt>. Note that it is perfectly acceptable in such circumstances to define more than one name association to the same DLL function specifying different argument types:</p><pre>      'FooScalar'⎕NA'mydll|foo &lt;T'   ⋄ FooScalar'a'
      'FooVector'⎕NA'mydll|foo &lt;T[]' ⋄ FooVector'abc'</pre><h4>Structures</h4><p>Arbitrary data structures, which are akin to nested arrays, are specified using the symbols <tt>{}</tt>. For example, the code <tt>{F8 I2}</tt> indicates a structure comprised of an 8-byte <span class="Italic">float </span>followed by a 2-byte <span class="Italic">int</span>. Furthermore, the code <tt>&lt;{F8 I2}[3]</tt> means an input pointer to an array of 3 such structures.</p><p>For example, this structure might be defined in C thus:</p><pre class="Code">typedef struct
{
    double  f;
    short   i;
} mystruct;</pre><p>A function defined to receive a count followed by an <span class="Italic">input</span> pointer to an array of such structures:</p><pre class="Code">void foo(unsigned count, mystruct *str);</pre><p>An appropriate <tt>⎕NA</tt> declaration would be:</p><pre>      ⎕NA'mydll.foo U &lt;{F8 I2}[]' </pre><p>A call on the function with two arguments - a count followed by a vector of structures:</p><pre>      foo 4,⊂(1.4 3)(5.9 1)(6.5 2)(0 0)</pre><p>Notice that for the above call, APL converts the two Boolean <tt>(0 0)</tt> elements to an 8-byte float and a 2-byte int, respectively.</p><h4>Specifying Pointers Explicitly</h4><p><tt>⎕NA</tt> syntax enables APL to pass arguments to DLL functions by <span class="Italic">value</span> or <span class="Italic">address</span> as appropriate. For example if a function requires an integer followed by a <span class="Italic">pointer</span> to an integer:</p><pre class="Code">void fun(int valu, int *addr);</pre><p>You might declare and call it:</p><pre>      ⎕NA'mydll|fun I &lt;I' ⋄ fun 42 42</pre><p>The interpreter passes the <span class="Italic">value</span> of the first argument and the <span class="Italic">address</span> of the second one.</p><p>Two common cases occur where it is necessary to pass a pointer explicitly. The first is if the DLL function requires a <span class="Italic">null pointer</span>, and the second is where you want to pass on a pointer which itself is a result from a DLL function.</p><p>In both cases, the pointer argument should be coded as <tt>P</tt>. This causes APL to pass the pointer unchanged, <span class="Italic">by value</span>, to the DLL function.</p><p>In the previous example, to pass a null pointer, (or one returned from another DLL function), you must code a separate <tt>⎕NA</tt> definition.</p><pre>      'fun_null'⎕NA'mydll|fun I P' ⋄ fun_null 42 0</pre><p>Now APL passes the <span class="Italic">value</span> of the second argument (in this case 0 - the null pointer), rather than its address.</p><p>Note that by using P, which is 4-byte for 32-bit processes and 8-byte for 64-bit processes, you will ensure that the code will run unchanged under both 32-bit and 64-bit versions of Dyalog APL. </p><h4>Using a Function</h4><p>A DLL function may or may not return a result, and may take zero or more arguments. This syntax is reflected in the coding of the right argument of <tt>⎕NA</tt>. Notice that the corresponding associated APL function is niladic or monadic (never dyadic), and that it <span class="Italic">always</span> returns a vector result - a null one if there is no output from the function. See <span class="XRef">Result Vector</span> section below. Examples of the various combinations are:</p><h4>DLL function Non-result-returning:</h4><pre>⎕NA    'mydll|fn1'          ⍝ Niladic
⎕NA    'mydll|fn2 &lt;0T'      ⍝ Monadic - 1-element arg
⎕NA    'mydll|fn3 =0T &lt;0T'  ⍝ Monadic - 2-element arg</pre><h4>DLL function Result-returning:</h4><pre>⎕NA 'I4 mydll|fn4'          ⍝ Niladic
⎕NA 'I4 mydll|fn5 F8'       ⍝ Monadic - 1-element arg
⎕NA 'I4 mydll|fn6 &gt;I4[] &lt;0T'⍝ Monadic - 2-element arg</pre><p>When the external function is called, the number of elements in the argument must match the number defined in the <tt>⎕NA</tt> definition. Using the example functions defined above:</p><pre>      fn1                   ⍝ Niladic Function.
      fn2, ⊂'Single String' ⍝ 1-element arg
      fn3 'This' 'That'     ⍝ 2-element arg</pre><p>Note in the second example, that you must enclose the argument string to produce a single item (nested) array in order to match the declaration. Dyalog converts the type of a numeric argument if necessary, so for example in fn5 defined above, a Boolean value would be converted to double floating point (F8) prior to being passed to the DLL function.</p><h4>Pointer Arguments</h4><p>When passing pointer arguments there are three cases to consider.</p><h4><tt>&lt;</tt>  Input pointer:</h4><p>  In this case you must supply the data array itself as argument to the function. A pointer to its first element is then passed to the DLL function.</p><pre>      fn2 ⊂'hello'</pre><h4><tt>&gt;</tt>  Output pointer:</h4><p> Here, you must supply the <b>number of elements</b> that the output will need in order for APL to allocate memory to accommodate the resulting array.</p><pre>      fn6 10 'world'  ⍝ 1st arg needs space for 10 ints.</pre><p>Note that if you were to reserve fewer elements than the DLL function actually used, the DLL function would write beyond the end of the reserved array and may cause the interpreter to crash with a System Error (syserr 999 on Windows or SIGSEGV on UNIX).</p><h4><tt>=</tt>  Input/Output:  </h4><p>As with the input-only case, a pointer to the first element of the argument is passed to the DLL function. The DLL function then overwrites some or all of the elements of the array, and the new value is passed back as part of the result of the call. As with the output pointer case, if the input array were too short, so that the DLL wrote beyond the end of the array, the interpreter would almost certainly crash.</p><pre>      fn3 '.....' 'hello'</pre><h4>Result Vector</h4><p>In APL, a function cannot overwrite its arguments. This means that any output from a DLL function must be returned as part of the explicit result, and this includes output via ‘output’ or ‘input/output’ pointer arguments.</p><p>The general form of the result from calling a DLL function is a nested vector. The first item of the result is the defined explicit result of the external function, and subsequent items are implicit results from output, or input/output pointer arguments.</p><p>The length of the result vector is therefore: 1 (if the function was declared to return an explicit result) + the number of output or input/output arguments. </p><table><tr><th class="Left"><tt>⎕NA</tt> Declaration</th><th class="Left">Result</th><th class="Left">Output Arguments</th><th class="Left">Result Length</th></tr><tr><td><tt>   mydll|fn1</tt></td><td><tt>0</tt></td><td><tt> </tt></td><td><tt>0</tt></td></tr><tr><td><tt>   mydll|fn2 &lt;0T</tt></td><td><tt>0</tt></td><td><tt>0</tt></td><td><tt>0</tt></td></tr><tr><td><tt>   mydll|fn3 =0T &lt;0T</tt></td><td><tt>0</tt></td><td><tt>1 0</tt></td><td><tt>1</tt></td></tr><tr><td><tt>I4 mydll|fn4</tt></td><td><tt>1</tt></td><td><tt> </tt></td><td><tt>1</tt></td></tr><tr><td><tt>I4 mydll|fn5 F8</tt></td><td><tt>1</tt></td><td><tt>0</tt></td><td><tt>1</tt></td></tr><tr><td><tt>I4 mydll|fn6 &gt;I4[] &lt;0T</tt></td><td><tt>1</tt></td><td><tt>1 0</tt></td><td><tt>2</tt></td></tr></table><p>As a convenience, if the result would otherwise be a 1-item vector, it is disclosed. Using the third example above:</p><pre>      ⍴fn3 '.....' 'abc'
5</pre><p><tt>fn3</tt> has no explicit result; its first argument is input/output pointer; and its second argument is input pointer. Therefore as the length of the result would be 1, it has been disclosed.</p><h4>ANSI /Unicode Versions of Library Calls</h4><p>Under Windows, most library functions that take character arguments, or return character results have two forms: one Unicode (Wide) and one ANSI. For example, a function such as <span class="Code">MessageBox()</span>, has two forms <span class="Code">MessageBoxA()</span> and <span class="Code">MessageBoxW()</span>. The <span class="Code">A</span> stands for ANSI (1-byte) characters, and the <span class="Code">W</span> for wide (2-byte Unicode) characters.</p><p>It is essential that you associate the form of the library function that is appropriate for the Dyalog Edition you are using, i.e. <span class="Code">MessageBoxA()</span> for the Classic Edition, but <span class="Code">MessageBoxW()</span> for the Unicode Edition.</p><p>To simplify writing portable code for both Editions, you may specify the character <tt>*</tt> instead of <tt>A</tt> or <tt>W</tt> at the end of a function name. This will be replaced by <tt>A</tt> in the Classic Edition and <tt>W</tt> in the Unicode Edition.</p><p>The default name of the associated function (if no left argument is given to <tt>⎕NA</tt>), will be without the trailing letter (<tt>MessageBox</tt>).</p><h4>Type Definitions (typedefs)</h4><p>The C language encourages the assignment of defined names to primitive and complex data types using its <span class="Code">#define</span> and <span class="Code">typedef</span> mechanisms. Using such abstractions enables the C programmer to write code that will be portable across many operating systems and hardware platforms.</p><p>Windows software uses many such names and Microsoft documentation will normally refer to the type of function arguments using defined names such as <span class="Code">HANDLE</span> or <span class="Code">LPSTR</span> rather than their equivalent C primitive types: <span class="Code">int</span> or <span class="Code">char*</span>.</p><p>It is beyond the scope of this manual to list <span class="Italic">all</span> the Microsoft definitions and their C primitive equivalents, and indeed, DLLs from sources other than Microsoft may well employ their own distinct naming conventions.</p><p>In general, you should consult the documentation that accompanies the DLL in order to convert typedefs to primitive C types and thence to <tt>⎕NA</tt> declarations. The documentation may well refer you to the ‘include’ files which are part of the Software Development Kit, and in which the types are defined.</p><p>The following table of some commonly encountered Windows typedefs and their <tt>⎕NA</tt> equivalents might prove useful.</p><table><tr><th class="Left">Windows typedef</th><th class="Left"><tt>⎕NA</tt> equivalent</th></tr><tr><td>HWND</td><td><tt>P</tt></td></tr><tr><td>HANDLE</td><td><tt>P</tt></td></tr><tr><td>GLOBALHANDLE</td><td><tt>P</tt></td></tr><tr><td>LOCALHANDLE</td><td><tt>P</tt></td></tr><tr><td>DWORD</td><td><tt>U4</tt></td></tr><tr><td>WORD</td><td><tt>U2</tt></td></tr><tr><td>BYTE</td><td><tt>U1</tt></td></tr><tr><td>LPSTR</td><td><tt><tt>=0T[] </tt>(note 1)</tt></td></tr><tr><td>LPCSTR</td><td><tt><tt>&lt;0T[] </tt>(note 2)</tt></td></tr><tr><td>WPARAM</td><td><tt>U (note 3)</tt></td></tr><tr><td>LPARAM</td><td><tt>U4 (note 3)</tt></td></tr><tr><td>LRESULT</td><td><tt>I4</tt></td></tr><tr><td>BOOL</td><td><tt>I</tt></td></tr><tr><td>UINT</td><td><tt>U</tt></td></tr><tr><td>ULONG</td><td><tt>U4</tt></td></tr><tr><td>ATOM</td><td><tt>U2</tt></td></tr><tr><td>HDC</td><td><tt>P</tt></td></tr><tr><td>HBITMAP</td><td><tt>P</tt></td></tr><tr><td>HBRUSH</td><td><tt>P</tt></td></tr><tr><td>HFONT</td><td><tt>P</tt></td></tr><tr><td>HICON</td><td><tt>P</tt></td></tr><tr><td>HMENU</td><td><tt>P</tt></td></tr><tr><td>HPALETTE</td><td><tt>P</tt></td></tr><tr><td>HMETAFILE</td><td><tt>P</tt></td></tr><tr><td>HMODULE</td><td><tt>P</tt></td></tr><tr><td>HINSTANCE</td><td><tt>P</tt></td></tr><tr><td>COLORREF</td><td><tt>{U1[4]}</tt></td></tr><tr><td>POINT</td><td><tt>{I I}</tt></td></tr><tr><td>POINTS</td><td><tt>{I2 I2}</tt></td></tr><tr><td>RECT</td><td><tt>{I I I I}</tt></td></tr><tr><td>CHAR</td><td><tt><tt>T </tt>or<tt> C</tt></tt></td></tr></table><h4>Notes</h4><ol><li value="1"><span class="Code">LPSTR</span> is a pointer to a null-terminated string. The definition does not indicate whether this is input or output, so the safest coding would be <tt>=0T[]</tt> (providing the vector you supply for input is long enough to accommodate the result). You may be able to improve simplicity or performance if the documentation indicates that the pointer is ‘input only’ (&lt;<tt>0T[]</tt>) or ‘output only’ (&gt;<tt>0T[]</tt>). See <span class="XRef">Direction</span> above.</li><li value="2"><span class="Code">LPCSTR</span> is a pointer to a <span class="Italic">constant</span> null-terminated string and therefore coding <tt>&lt;0T[]</tt> is safe.</li><li value="3"><span class="Code">WPARAM</span> is an unsigned value, <span class="Code">LPARAM</span> is signed.
They are 32 bit values in a 32-bit APL, and 64-bit in a 64 bit APL.
You should consult the documentation for the specific function that you intend to call to determine what type they represent
</li><li value="4">The use of  type T with default width ensures portability of code between Classic and Unicode Editions. In the Classic Edition, T (with no width specifier) implies 1-byte characters which are translated between  <tt>⎕AV</tt> and ASCII, while In the Unicode Edition, T (with no width specifier) implies 2-byte (Unicode) characters.</li></ol><h4>Dyalog32.dll or Dyalog64.dll</h4><p>Included with Dyalog APL are utility DLLs called dyalog32.dll and dyalog64.dll. These DLLs contain three functions: MEMCPY, STRNCPY and STRLEN.</p><h4 class="ExampleNewPage">MEMCPY</h4><p><tt>MEMCPY</tt> is an extremely versatile function used for moving arbitrary data between memory buffers.</p><p>Its C definition is:</p><pre class="Code">void *MEMCPY(       // copy memory
      void *to,     // target address
      void *fm,     // source address
      size_t size   // number of bytes to copy
      );</pre><p><tt>MEMCPY</tt> copies <span class="Code">size</span> bytes starting from source address <span class="Code">fm</span>, to destination address <span class="Code">to</span>. The source and destination areas should not overlap; if they do the behaviour is undefined and the result is the first argument.</p><p><tt>MEMCPY</tt>’s versatility stems from being able to associate to it using many different type declarations. </p><h4>Example</h4><p>Suppose a global buffer (at address: <tt>addr</tt>) contains (<tt>numb</tt>) double floating point numbers. To copy these to an APL array, we could define the association:</p><pre>      'doubles' ⎕NA 'dyalog32|MEMCPY &gt;F8[] I4 U4'
      doubles numb addr (numb×8)</pre><p>Notice that:</p><ul><li value="1">As the first argument to <tt>doubles</tt> is an output argument, we must supply the number of elements to reserve for the output data.</li><li value="2"><tt>MEMCPY</tt> is defined to take the number of <span class="Italic">bytes</span> to copy, so we must multiply the number of elements by the element size in bytes.</li></ul><h4>Example</h4><p>Suppose that a database application requires that we construct a record in global memory prior to writing it to file. The record structure might look like this:</p><pre class="Code">typedef struct {
        int empno;// employee number.
        float salary;// salary.
        char name[20];// name.
        } person;</pre><p>Then, having previously allocated memory (<tt>addr</tt>) to receive the record, we can define:</p><pre>      'prec' ⎕NA 'dyalog32|MEMCPY I4 &lt;{P F4 T[20]} U4'
      prec addr(99 12345.60 'Charlie Brown')(4+4+20)</pre><h4 class="ExampleNewPage">STRNCPY</h4><p><tt>STRNCPY</tt> is used to copy null-terminated strings between memory buffers.</p><p>Its C definition is:</p><pre class="Code">void *STRNCPY(// copy null-terminated string
        char *to,// target address
        char *fm,// source address
        size_t size// MAX number of chars to copy
        );</pre><p><tt>STRNCPY</tt> copies a maximum of <span class="Code">size</span> characters from the null-terminated source string at address <span class="Code">fm</span>, to the destination address <span class="Code">to</span>. If the source and destination strings overlap, the result is the first argument.</p><p>If the source string is shorter than <span class="Code">size</span>, null characters are appended to the destination string.</p><p>If the source string (including its terminating null) is longer than <span class="Code">size</span>, only <span class="Code">size</span> characters are copied and the resulting destination string is not null-terminated </p><h4>Example</h4><p>Suppose that a database application returns a pointer (<tt>addr</tt>) to a structure that contains two pointers to (max 20-char) null-terminated strings.</p><pre class="Code">typedef struct {  // null-terminated strings:
        char *first;  // first name (max 19 chars + 1 null).
        char *last;  // last name. (max 19 chars + 1 null).
        } name;</pre><p>To copy the names <span class="Italic">from</span> the structure:</p><pre>      'get'⎕NA'dyalog32|STRNCPY &gt;0T[] P U4'
      get 20 addr 20
Charlie
      get 20 (addr+4) 20
Brown</pre><p>Note that on a 64-bit version, <tt>⎕FR</tt> will need to be 1287 for the addition to be reliable.</p><p>To copy data <span class="Italic">from</span> the workspace <span class="Italic">into</span> an already allocated (<tt>new</tt>) structure:</p><pre>      'put'⎕NA'dyalog32|STRNCPY I4 &lt;0T[] U4'
      put new 'Bo' 20
      put (new+4) 'Peep' 20</pre><p>Notice in this example that you must ensure that names no longer than 19 characters are passed to <tt>put</tt>. More than 19 characters would not leave STRNCPY enough space to include the trailing null, which would probably cause the application to fail.</p><h4>STRLEN</h4><p><tt>STRLEN</tt> calculates the length of a C string (a 0-terminated string of bytes in memory). Its C declaration is:</p><pre class="Code">size_t STRLEN(         // calculate length of string
        const char *s    // address of string
        );</pre><h4>Example</h4><p>Suppose that a database application returns a pointer (<tt>addr</tt>) to a null-terminated string and you do not know the upper bound on the length of the string.</p><p>To copy the string into the workspace:</p><pre>      'len' ⎕NA'P dyalog32|STRLEN P'
      'cpy'⎕NA'dyalog32|MEMCPY &gt;T[] P P'
      cpy l addr (l←len addr)
Bartholemew</pre><h4>Examples</h4><p>The following examples all use functions from the Microsoft Windows user32.dll.</p><p>This DLL should be located in a standard Windows directory, so you should not normally need to give the full path name of the library. However if trying these examples results in the error message ‘FILE ERROR 1 No such file or directory’, you must locate the DLL and supply the full path name (and possibly extension).</p><h4>Example 1</h4><p>The Windows function "<span class="Code">GetCaretBlinkTime</span>" retrieves the caret blink rate.  It takes no arguments and returns an unsigned <span class="Italic">int</span> and is declared as follows:</p><p><span class="Code">UINT GetCaretBlinkTime(void);</span></p><p>The following statements would provide access to this routine through an APL function of the same name.</p><pre>      ⎕NA 'U user32|GetCaretBlinkTime'
      GetCaretBlinkTime
530</pre><p>The following statement would achieve the same thing, but using an APL function called <tt>BLINK</tt>.</p><pre>      'BLINK' ⎕NA 'U user32|GetCaretBlinkTime'
      BLINK
530</pre><h4>Example 2</h4><p>The Windows function "<span class="Code">SetCaretBlinkTime</span>" sets the caret blink rate.  It takes a single unsigned <span class="Italic">int</span> argument, does not return a result and is declared as follows:</p><p><span class="Code">void SetCaretBlinkTime(UINT);</span></p><p>The following statements would provide access to this routine through an APL function of the same name:</p><pre>      ⎕NA 'user32|SetCaretBlinkTime U'
      SetCaretBlinkTime 1000</pre><h4>Example 3</h4><p>The Windows function "<span class="Code">MessageBox</span>" displays a standard dialog box on the screen and awaits a response from the user.  It takes 4 arguments.  The first is the window handle for the window that owns the message box.  This is declared as an unsigned <span class="Italic">int</span>.  The second and third arguments are both pointers to null-terminated strings containing the message to be displayed in the Message Box and the caption to be used in the window title bar.  The 4th argument is an unsigned <span class="Italic">int</span> that specifies the Message Box type.  The result is an <span class="Italic">int</span> which indicates which of the buttons in the message box the user has pressed.  The function is declared as follows:</p><pre class="Code">int MessageBox(HWND, LPCSTR, LPCSTR, UINT);</pre><p>The following statements provide access to this routine through an APL function of the same name. Note that the 2nd and 3rd arguments are both coded as input pointers to type T null-terminated character arrays which ensures portability between Editions.</p><pre>      ⎕NA 'I user32|MessageBox* P &lt;0T &lt;0T U'</pre><p>The following statement displays a Message Box with a stop sign icon together with 2 push buttons labelled OK and Cancel (this is specified by the value 19).</p><pre>      MessageBox 0 'Message' 'Title' 19</pre><p>The function works equally well in the Unicode Edition because the &lt;0T specification is portable.</p><pre>      MessageBox 0 'Το Μήνυμα' 'Ο Τίτλος' 19</pre><p>Note that a simpler, portable (and safer) method for displaying a Message Box is to use Dyalog APL’s primitive <tt>MsgBox</tt> object.</p><h4>Example 4</h4><p>The Windows function "<span class="Code">FindWindow</span>" obtains the window handle of a window which has a given character string in its title bar.  The function takes two arguments.  The first is a pointer to a null-terminated character string that specifies the window's class name. However, if you are not interested in the class name, this argument should be a NULL pointer.  The second is a pointer to a character string that specifies the title that identifies the window in question.  This is an example of a case described above where two instances of the function must be defined to cater for the two different types of argument.  However, in practice this function is most often used without specifying the class name.  The function is declared as follows:</p><p><span class="Code">HWND FindWindow(LPCSTR, LPCSTR);</span></p><p>The following statement associates the APL function <tt>FW</tt> with the second variant of the FindWindow call, where the class name is specified as a NULL pointer.  To indicate that APL is to pass the <span class="Italic">value</span> of the NULL pointer, rather than its address, we need to code this argument as <tt>I4</tt>.</p><pre>      'FW' ⎕NA 'P user32|FindWindow* I4 &lt;0T'</pre><p>To obtain the handle of the window entitled "CLEAR WS - Dyalog APL/W":</p><pre>      ⎕←HNDL←FW 0 'CLEAR WS - Dyalog APL/W'
59245156</pre><h4>Example 5</h4><p>The Windows function "<span class="Code">GetWindowText</span>" retrieves the caption displayed in a window's title bar.  It takes 3 arguments.  The first is an unsigned <span class="Italic">int</span> containing the window handle.  The second is a pointer to a buffer to receive the caption as a null-terminated character string.  This is an example of an output array.  The third argument is an <span class="Italic">int</span> which specifies the maximum number of characters to be copied into the output buffer.  The function returns an <span class="Italic">int</span> containing the actual number of characters copied into the buffer and is declared as follows:</p><p><span class="Code">int GetWindowText(HWND, LPSTR, int);</span></p><p>The following associates the "<span class="Code">GetWindowText</span>" DLL function with an APL function of the same name.  Note that the second argument is coded as "<tt>&gt;0T</tt>" indicating that it is a pointer to a character output array.</p><pre>      ⎕NA 'I user32|GetWindowText* P &gt;0T I'</pre><p>Now change the Session caption using <tt>)WSID</tt> :</p><pre>      )WSID MYWS
was CLEAR WS</pre><p>Then retrieve the new caption (max length 255) using window handle <tt>HNDL</tt> from the previous example:</p><pre>      ]display GetWindowText HNDL 255 255
.→-------------------------.
|    .→------------------. |
| 19 |MYWS - Dyalog APL/W| |
|    '-------------------' |
'∊-------------------------'</pre><p>There are three points to note.  Firstly, the number 255 is supplied as the second argument.  This instructs APL to allocate a buffer large enough for a 255-element character vector into which the DLL routine will write.  Secondly, the result of the APL function is a nested vector of 2 elements.  The first element is the result of the DLL function.  The second element is the output character array. </p><p>Finally, notice that although we reserved space for 255 elements, the result reflects the length of the actual text (19).</p><p>An alternative way of coding and using this function is to treat the second argument as an input/output array.</p><p>e.g.</p><pre>      ⎕NA 'I User32|GetWindowText* P =0T I'
 
      ]display GetWindowText HNDL (255⍴' ') 255
.→-------------------------.
|    .→------------------. |
| 19 |MYWS - Dyalog APL/W| |
|    '-------------------' |
'∊-------------------------'</pre><p>In this case, the second argument is coded as <tt>=0T</tt>, so when the function is called an array of the appropriate size must be supplied.  This method uses more space in the workspace, although for small arrays (as in this case) the real impact of doing so is negligible.</p><h4>Example 6</h4><p>The function "<span class="Code">GetCharWidth</span>" returns the width of each character in a given range  Its first argument is a device context (handle).  Its second and third arguments specify font positions (start and end).  The third argument is the resulting integer vector that contains the character widths (this is an example of an output array).  The function returns a Boolean value to indicate success or failure.  The function is defined as follows.  Note that this function is provided in the library: gdi32.dll.</p><p><span class="Code">BOOL GetCharWidth(HDC, UINT, UINT, int FAR*);</span></p><p>The following statements provide access to this routine through an APL function of the same name:</p><pre>      ⎕NA 'U4 gdi32|GetCharWidth* P U U &gt;I[]'
 
     'P'⎕WC'Printer'
 
      ]display GetCharWidth ('P' ⎕WG 'Handle') 65 67 3 
.→-------------.
|   .→-------. |
| 1 |50 50 50| |
|   '~-------' |
'∊-------------'</pre><p>Note: <tt>'P'⎕WG'Handle'</tt> returns a handle This is represented as a number. The number will be in the range (0 - 2*32] on a 32-bit version and (0 - 2*64] on a 64-bit version. These can be passed to a P type parameter. Older versions used a 32-bit signed integer.</p><h4>Example 7</h4><p>The following example from the supplied workspace: <tt>QUADNA.DWS</tt> illustrates several techniques which are important in advanced <tt>⎕NA</tt> programming. Function <tt>DllVersion</tt> returns the major and minor version number for a given DLL. Note that this example assumes that the computer is running the 64-bit version of Dyalog.</p><p>In advanced DLL programming, it is often necessary to administer memory outside APL’s workspace. In general, the procedure for such use is:</p><ol><li value="1">Allocate global memory.</li><li value="2">Lock the memory.</li><li value="3">Copy any DLL input information from workspace into memory.</li><li value="4">Call the DLL function.</li><li value="5">Copy any DLL output information from memory to workspace.</li><li value="6">Unlock the memory.</li><li value="7">Free the memory.</li></ol><p>Notice that steps 1 and 7 and steps 2 and 6 complement each other. That is, if you allocate global system memory, you must free it after you have finished using it. If you continue to use global memory without freeing it, your system will gradually run out of resources. Similarly, if you lock memory (which you must do before using it), then you should unlock it before freeing it. Although on some versions of Windows, freeing the memory will include unlocking it, in the interests of good style, maintaining the symmetry is probably a good thing.</p><p class="pagebreakafter"> </p><pre>    ∇ version←DllVersion file;Alloc;Free;Lock;Unlock;Size
                  ;Info;Value;Copy;size;hndl;addr;buff;ok
[1]
[2]  'Alloc'⎕NA'P kernel32|GlobalAlloc U4 U4'
[3]   'Free'⎕NA'P kernel32|GlobalFree P'
[4]   'Lock'⎕NA'P kernel32|GlobalLock P'
[5] 'Unlock'⎕NA'U4 kernel32|GlobalUnlock P'
[6]
[7]  'Size'⎕NA'U4 version|GetFileVersionInfoSize* &lt;0T &gt;U4'
[8]  'Info'⎕NA'U4 version|GetFileVersionInfo*&lt;0T U4 U4 P'
[9] 'Value'⎕NA'U4 version|VerQueryValue* P &lt;0T &gt;P &gt;U4'
[10]
[11] 'Copy'⎕NA'dyalog64|MEMCPY &gt;U4[] P P'
[12]
[13]  :If ×size←⊃Size file 0               ⍝ Size of info
[14]  :AndIf ×hndl←Alloc 0 size            ⍝ Alloc memory
[15]    :If ×addr←Lock hndl                ⍝ Lock memory
[16]      :If ×Info file 0 size addr       ⍝ Version info
[17]        ok buff size←Value addr'\' 0 0 ⍝ Version value
[18]        :If ok
[19]          buff←Copy(size÷4)buff size   ⍝ Copy info
[20]          version←(2/2*16)⊤⊃2↓buff     ⍝ Split version
[21]        :EndIf
[22]      :EndIf
[23]      ok←Unlock hndl                   ⍝ Unlock memory
[24]    :EndIf
[25]    ok←Free hndl                       ⍝ Free memory
[26]  :EndIf
    ∇</pre><p>Lines [2-11] associate APL function names with the DLL functions that will be used.</p><p>Lines [2-5] associate functions to administer global memory. </p><p>Lines [7-9] associate functions to extract version information from a DLL.</p><p>Line[11] associates <tt>Copy</tt> with <tt>MEMCPY</tt> function from <b>dyalog64.dll</b>.</p><p>Lines [13-26] call the DLL functions.</p><p>Line [13] requests the size of buffer required to receive version information for the DLL. A size of 0 will be returned if the DLL does not contain version information.</p><p><b>Notice that</b> care is taken to balance memory allocation and release:</p><p>On line [14], the :If clause is taken only if the global memory allocation is successful, in which case (and only then) a corresponding Free is called on line [25].</p><p>Unlock on line[23] is called if  and only if the call to Lock on line [15] succeeds.</p><p>A result is returned from the function <span class="Italic">only</span> if all the calls are successful Otherwise, the calling environment will sustain a <tt>VALUE ERROR</tt>.</p><h4>More Examples </h4><pre class="APLCodeSmall">⎕NA'I4 advapi32 |RegCloseKey          P'
⎕NA'I4 advapi32 |RegCreateKeyEx*      P &lt;0T U4 &lt;0T U4 U4 P &gt;P &gt;U4'
⎕NA'I4 advapi32 |RegEnumValue*        P U4 &gt;0T =U4 =U4 &gt;U4 &gt;0T =U4'
⎕NA'I4 advapi32 |RegOpenKey*          P &lt;0T &gt;P'
⎕NA'I4 advapi32 |RegOpenKeyEx*        P &lt;0T U4 U4 &gt;P'
⎕NA'I4 advapi32 |RegQueryValueEx*     P &lt;0T =U4 &gt;U4 &gt;0T =U4'
⎕NA'I4 advapi32 |RegSetValueEx*       P &lt;0T =U4 U4 &lt;0T U4'
⎕NA'P  dyalog32 |STRNCPY              P P P'
⎕NA'P  dyalog32 |STRNCPYA             P P P'
⎕NA'P  dyalog32 |STRNCPYW             P P P'
⎕NA'P  dyalog32 |MEMCPY               P P P'
⎕NA'I4 gdi32    |AddFontResource*     &lt;0T'
⎕NA'I4 gdi32    |BitBlt               P I4 I4 I4 I4 P I4 I4 U4'
⎕NA'U4 gdi32    |GetPixel             P I4 I4'
⎕NA'P  gdi32    |GetStockObject       I4'
⎕NA'I4 gdi32    |RemoveFontResource*  &lt;0T'
⎕NA'U4 gdi32    |SetPixel             P I4 I4 U4'
⎕NA'   glu32    |gluPerspective       F8 F8 F8 F8'
⎕NA'I4 kernel32 |CopyFile*            &lt;0T &lt;0T I4'
⎕NA'P  kernel32 |GetEnvironmentStrings'
⎕NA'U4 kernel32 |GetLastError'
⎕NA'U4 kernel32 |GetTempPath*         U4 &gt;0T'
⎕NA'P  kernel32 |GetProcessHeap'
⎕NA'I4 kernel32 |GlobalMemoryStatusEx ={U4 U4 U8 U8 U8 U8 U8 U8}'
⎕NA'P  kernel32 |HeapAlloc            P U4 P'
⎕NA'I4 kernel32 |HeapFree             P U4 P'
⎕NA'   opengl32 |glClearColor         F4 F4 F4 F4'
⎕NA'   opengl32 |glClearDepth         F8'
⎕NA'   opengl32 |glEnable             U4'
⎕NA'   opengl32 |glMatrixMode         U4'
⎕NA'I4 user32   |ClientToScreen       P ={I4 I4}'
⎕NA'P  user32   |FindWindow*          &lt;0T &lt;0T'
⎕NA'I4 user32   |ShowWindow           P I4'
⎕NA'I2 user32   |GetAsyncKeyState     I4'
⎕NA'P  user32   |GetDC                P'
⎕NA'I4 User32   |GetDialogBaseUnits'
⎕NA'P  user32   |GetFocus'
⎕NA'U4 user32   |GetSysColor          I4'
⎕NA'I4 user32   |GetSystemMetrics     I4'
⎕NA'I4 user32    |InvalidateRgn        P P I4'
⎕NA'I4 user32   |MessageBox*          P &lt;0T &lt;0T U4'
⎕NA'I4 user32   |ReleaseDC            P P'
⎕NA'P  user32   |SendMessage*         P U4 P P'
⎕NA'P  user32   |SetFocus             P'
⎕NA'I4 user32   |WinHelp*             P &lt;0T U4 P'
⎕NA'I4 winnm    |sndPlaySound         &lt;0T U4'
</pre><script src="../../../help.js"></script></body>
</html>