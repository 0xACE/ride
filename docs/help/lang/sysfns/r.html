<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><tt>R←{X}(A ⎕R B) Y</tt>Replace </h2><p><tt>⎕R</tt> (Replace) and <tt>⎕S</tt> (Search) are system operators which take search pattern(s) as their left arguments and transformation rule(s) as their right arguments; the derived function operates on text data to perform either a <b>search</b>, or a search and <b>replace</b> operation.</p><p>The search patterns may include <span class="Italic">Regular Expressions</span> so that complex searches may be performed. <tt>⎕R</tt> and <tt>⎕S</tt> utilise the open-source regular-expression search engine PCRE, which is built into Dyalog APL and distributed according to the <a href="../appendices/pcre-license.html#PCRE_Licence">PCRE license</a> which is published separately.</p><p>The transformation rules are applied to the text which matches the search patterns; they may be given as a simple character vector, numeric codes, or  a function.</p><p>The two system operators, <tt>⎕R</tt> for replace and <tt>⎕S</tt> for search, are syntactically identical. With <tt>⎕R</tt>, the input document is examined; text which matches the search pattern is amended and the remainder is left unchanged. With <tt>⎕S</tt>, each match in the input document results in an item in the result whose type is dependent on the transformation specified.The operators use the Variant operator to set options.</p><p><tt>A</tt> specifies one or more search patterns, being given as a single character, a character vector, a vector of character vectors or a vector of both characters and character vectors. See <span class="XRef">search pattern</span> following.</p><p><tt>B</tt> is the transformation to be performed on matches within the input document; it may be either one or more transformation patterns (specified as a character, a character vector, a vector of character vectors, or a vector of both characters and character vectors), one or more transformation codes (specified as a numeric scalar or a numeric vector) or a function; see <span class="XRef"> transformation pattern</span>, <span class="XRef">transformation codes</span> and <span class="XRef">transformation function</span> following.</p><p><tt>Y</tt> specifies the input document; see <span class="XRef">input document</span> below.</p><p><tt>X</tt> optionally specifies an output stream; see <span class="XRef">output</span> below.</p><p><tt>R</tt> is the result value; see <span class="XRef">output</span> below.</p><h4>Examples of replace operations</h4><pre>      ('.at' ⎕R '\u0') 'The cat sat on the mat'     
The CAT SAT on the MAT</pre><p>In the search pattern the dot matches any character, so the pattern as a whole matches sequences of three characters ending ‘at’. The transformation is given as a character string, and causes the entire matching text to be folded to upper case.</p><pre>      ('\w+' ⎕R {⌽⍵.Match}) 'The cat sat on the mat'
ehT tac tas no eht tam</pre><p>The search pattern matches each word. The transformation is given as a function, which receives a namespace containing various variables describing the match, and it returns the match in reverse, which in turn replaces the matched text.</p><h4>Examples of search operations</h4><pre>      STR←'The cat sat on the mat'
      ('.at' ⎕S '\u0') STR
CAT  SAT  MAT </pre><p>The example is identical to the first, above, except that after the transformation is applied to the matches the results are returned in a vector, not substituted into the source text.</p><pre>      ('.at' ⎕S {⍵.((1↑Offsets),1↑Lengths)}) STR
4 3  8 3  19 3</pre><p>When searching, the result vector need not contain only text and in this example the function returns the numeric position and length of the match given to it; the resultant vector contains these values for each of the three matches.</p><pre>      ('.at' ⎕S 0 1) STR       
4 3  8 3  19 3</pre><p>Here the transformation is given as a vector of numeric codes which are a short-hand for the position and length of each match; the overall result is therefore identical to the previous example.</p><p>These examples all operate on a simple character vector containing text, but the text may be given in several forms - character vectors, vectors of character vectors, and external data streams. These various forms constitute a ‘document’. When the result also takes the form of a document it may be directed to a stream.</p><h4><a name="Input_Document"></a>Input Document</h4><p>The input document may be an array or a data stream. </p><p>When it is an array it may be given in one of two forms:</p><ol><li value="1">A character scalar or vector</li><li value="2">A vector of character vectors</li></ol><p>Currently, the only supported data stream is a native file, specified as tie number, which is read from the current position to the end. If the file is read from the start, and there is a valid Byte Order Mark (BOM) at the start of it, the data encoding is determined by this BOM. Otherwise, data in the file is assumed to be encoded as specified by the <b>InEnc</b> option.</p><p>Hint: once a native file has been read to the end by <tt>⎕R</tt> or <tt>⎕S</tt> it is possible to reset the file position to the start so that it may be read again using:</p><pre>      {} ⎕NREAD tienum 82 0 0</pre><p>The input document is comprised of lines of text. Line breaks may be included in the data:</p><p>Implicitly</p><ul><li value="1">Between each item in the outer vector (type 2, above)</li></ul><p>Explicitly, as</p><ul><li value="1">carriage return</li><li value="2">line feed</li><li value="3">carriage return and line feed together, in that order</li><li value="4">vertical tab (U+000B)</li><li value="5">newline (U+0085)</li><li value="6">form Feed (U+000C)</li><li value="7">line Separator (U+2028)</li><li value="8">paragraph Separator (U+2029)</li></ul><p>The implicit line ending character may be set using the <b>EOL</b> option. Explicit line ending characters may also be replaced by this character - so that all line endings are normalised - using the <b>NEOL</b> option.</p><p>The input document may be processed in <b>line </b>mode, <b>document </b>mode or <b>mixed </b>mode. In document mode and mixed mode, the entire input document, line ending characters included, is passed to the search engine; in line mode the document is split on line endings and passed to the search engine in sections without the line ending characters. The choice of mode affects both memory usage and behaviour, as documented in the section ‘Line, document and mixed modes’.</p><h4><a name="Output"></a>Output</h4><p>The format of the output is dependent on whether <tt>⎕S</tt> or <tt>⎕R</tt> are in use, whether an output stream is specified and, for <tt>⎕R</tt>, the form of the input and whether the <b>ResultText</b> option is specified.</p><p>An output data stream may optionally be specified. Currently, the only supported data stream is a native file, specified as tie number, and all output will be appended to it. Data in the stream is encoded as specified by the <b>OutEnc</b> option. If this encoding specifies a Byte Order Mark and the file is initially empty then the Byte Order Mark will be written at the start. Appending to existing data using a different encoding is permitted but unlikely to produce desirable results. If an input stream is also used, care must be taken to ensure the input and output streams are not the same.</p><h4 class="Dyalog"><tt>⎕R</tt></h4><p>With no output stream specified and unless overridden by the <b>ResultText</b> option, the derived function result will be a document which closely matches the format of the input document, as follows:</p><p>A <b>character scalar or vector</b> input will result in a <b>character vector</b> output. Any and all line endings in the output will be represented by line ending characters within the character vector.</p><p>A <b>vector of character vectors</b> as input will result in a <b>vector of character vectors</b> as document output. Any and all line endings in the output document will be implied at the end of each character vector.  </p><p>A <b>stream</b> as input will result in a <b>vector of character vectors</b> document output. Any and all line endings in the output document will be implied at the end of each character vector.  </p><p>Note that the shape of the output document may be significantly different to that of the input document.</p><p>If the <b>ResultText</b> option is specified, the output type may be forced to be a <b>character vector</b> or <b>vector of character vectors</b> as described above, regardless of the input document.</p><p>With an output stream specified there is no result - instead the text is appended to the stream. If the appended text does not end with a line ending character then the line ending character specified by the <b>EOL</b> option is also appended. </p><h4 class="Dyalog"><tt>⎕S</tt></h4><p>With no output stream specified, the result will be a vector containing one item for each match in the input document, of types determined by the transformation performed on each match. </p><p>With an output stream specified there is no result - instead each match is appended to the stream. If any match does not end with a line ending character then the line ending character specified by the <b>EOL</b> option is also appended. Only text may be written to the stream, which means:</p><ul><li value="1">When a transformation function is used, the function may only generate a character vector result.</li><li value="2">Transformation codes may not be used.</li></ul><h4>Search pattern</h4><p>A summary of the syntax of the search pattern is reproduced from the PCRE documentation. See <a href="../appendices/pcre-regular-expression-syntax-summary.html#PCRE_Summary">PCRE Regular Expression Syntax Summary.htm</a>.</p><p>A full description is provided in <a href="../appendices/pcre-regular-expression-details.html#PCRE_Regular_Expression_Details">PCRE Regular Expression Details.htm</a>.</p><p>There may be multiple search patterns. If more than one search pattern is specified and more than one pattern matches the same part of the input document then priority is given to the pattern specified first.</p><p>Note that when anchoring a search to the beginning of a line, it is essential to use <tt>^</tt> (<tt>⎕UCS 94</tt>), not <tt>∧</tt> (<tt>⎕ucs 8743</tt>).</p><h4>Transformation pattern</h4><p>For each match in the input document, the transformation pattern causes the creation of text which, for <tt>⎕R</tt>, replaces the matching text and, for <tt>⎕S</tt>, generates one item in the result.</p><p>There may be either one transformation pattern, or the same number of transformation patterns as search patterns. If there are multiple search patterns and multiple transformation patterns then the transformation pattern used corresponds to the search pattern which matched the input text.</p><p>Transformation patterns may not be mixed with transformation codes or functions.</p><p>The following characters have special meaning:</p><table><tr><td>%</td><td>acts as a placeholder for the entire line (line mode) or document (document mode or mixed mode) which contained the match</td></tr><tr><td>&amp;</td><td>acts as a placeholder for the entire portion of text which matched</td></tr><tr><td>\n</td><td>represents a line feed character</td></tr><tr><td>\r</td><td>represents a carriage return</td></tr><tr><td>\0</td><td>equivalent to &amp;</td></tr><tr><td>\<span class="Italic">n</span></td><td>acts as a placeholder for the text which matched the first to ninth subpattern; <span class="Italic">n</span> may be any single digit value from 1 to 9</td></tr><tr><td>\(<span class="Italic">n</span>)</td><td>acts as a placeholder for the text which matched the numbered subpattern; <span class="Italic">n</span> may have an integer value from 0 to 63.</td></tr><tr><td>\&lt;<span class="Italic">name</span>&gt;</td><td>acts as a placeholder for the text which matched the named subpattern </td></tr><tr><td>\\</td><td>represents the backslash character</td></tr><tr><td>\%</td><td>represents the percent character </td></tr><tr><td>\&amp;</td><td>represents the ampersand character</td></tr></table><p>The above may be qualified to fold matching text to upper- or lower-case by using the <b>u</b> and <b>l</b> modifiers respectively. Character sequences beginning with the backslash place the modifier after the backslash; character sequences with no leading backslash add both a backslash and the modifier to the start of the sequence, for example:</p><table><tr><td>\u&amp;</td><td>acts as a placeholder for the entire portion of text which matched, folded to upper case</td></tr><tr><td>\l0</td><td>equivalent to \l&amp;</td></tr></table><p>Character sequences beginning with the backslash other that those shown are invalid. All characters other than those shown are literal values and are included in the text without modification.</p><h4>Transformation codes</h4><p>The transformation codes are a numeric scalar or vector. Transformation codes may only be used with <tt>⎕S</tt>. For each match in the input document, a numeric scalar or vector of the same shape as the transformation codes is created, with the codes replaced with values as follows:</p><table><tbody><tr><td>0</td><td>The offset from the start of the line (line mode) or document (document mode or mixed mode) of the start of the match, origin zero.</td></tr><tr><td>1</td><td>The length of the match.</td></tr><tr><td>2</td><td>In line mode, the block number in the source document of the start of the match. The value is origin zero. In document mode or mixed mode this value is always zero.</td></tr><tr><td>3</td><td>The pattern number which matched the input document, origin zero. </td></tr></tbody></table><h4>Transformation Function</h4><p>The transformation function is called for each match within the input document.  The function is monadic and is passed a namespace, containing the following variables:</p><table><tr><td><tt>Block</tt></td><td>The entire line (line mode) or document (document mode or mixed mode) in which the match was found.</td></tr><tr><td><tt>BlockNum</tt></td><td>With line mode, the block (line) number in the source document of the start of the match. The value is origin zero. With document mode or mixed mode the entire document is contained within one block and this value is always zero.</td></tr><tr><td><tt>Pattern</tt></td><td>The search pattern which matched.</td></tr><tr><td><tt>PatternNum</tt></td><td>The index-zero pattern number which matched.</td></tr><tr><td><tt>Match</tt></td><td>The text within Block which matched Pattern.</td></tr><tr><td><tt>Offsets</tt></td><td>A vector of one or more index-zero offsets relative to the start of Block. The first value is the offset of the entire match; any and all additional values are the offsets of the portions of the text which matched the subpatterns, in the order of the subpatterns within Pattern.</td></tr><tr><td><tt>Lengths</tt></td><td>A vector of one or more lengths, corresponding to each value in Offset.</td></tr><tr><td><tt>Names</tt></td><td>A vector of one or more character vectors corresponding to each of the values in Offsets, specifying the names given to the subpatterns within Pattern. The first entry (corresponding to the match) and all subpatterns with no name are included as length zero character vectors.</td></tr><tr><td><tt>ReplaceMode</tt></td><td>A Boolean indicating whether the function was called by <tt>⎕R</tt> (value 1) or <tt>⎕S</tt> (value 0).</td></tr><tr><td><tt>TextOnly</tt></td><td>A Boolean indicating whether the return value from the function must be a character vector (value 1) or any value (value 0).</td></tr></table><p>The return value from the function is used as follows:</p><p>With <tt>⎕R</tt> the function must return a character vector. The contents of this vector are used to replace the matching text.</p><p>With <tt>⎕S</tt> the function may return no value. If it does return a value:</p><ul><li value="1">When output is being directed to a stream it must be a character vector.</li><li value="2">Otherwise, it may be any value. The overall result of the derived function is the catenation of the enclosure of each returned value into a single vector.</li></ul><p>The passed namespace exists over the lifetime of <tt>⎕R</tt> or <tt>⎕S</tt>; the function may therefore preserve state by creating variables in the namespace.</p><p>The function may itself call <tt>⎕R</tt> or <tt>⎕S</tt>.</p><p>The locations of the match within Block and subpatterns within Match are given as offsets rather than positions, i.e. the values are the number of characters preceding the data, and are not affected by the Index Origin.</p><p>There may be only one transformation function, regardless of the number of search patterns.</p><h4>Options</h4><p>Options are specified using the Variant operator. The Principal option is IC.</p><p>Default values are highlighted <span class="DefaultOption">thus</span>. </p><h4>IC Option</h4><p>When set, case is ignored in searches. </p><table><tr><td><tt>1 </tt></td><td>Matches are not case sensitive.</td></tr><tr><td class="DefaultOption">0 </td><td>Matches are case sensitive.</td></tr></table><p>Example:</p><pre>      ('[AEIOU]' ⎕R 'X' ⍠ 'IC' 1) 'ABCDE abcde'
XBCDX XbcdX
      ('[AEIOU]' ⎕R 'X' ⍠ 1)'ABCDE abcde'
XBCDX XbcdX</pre><h4>Mode Option</h4><p>Specifies whether the input document is interpreted in <b>line</b> mode, <b>document</b> mode or <b>mixed</b> mode. </p><table><tr><td class="DefaultOption">L</td><td>When line mode is set, the input document is split into separate lines (discarding the line ending characters themselves), and each line is processed separately. This means that the <b>ML</b> option applies per line, and the '^' and '$' anchors match the start and end respectively of each line. Because the document is split, searches can never match across multiple lines, nor can searches for line ending characters ever succeed. Setting line mode can result in significantly reduced memory requirements compared with the other modes.</td></tr><tr><td><tt>D</tt></td><td>When document mode is set, the entire input document is processed as a single block. The <b>ML</b> option applies to this entire block, and the '^' and '$' anchors match the start and end respectively of the block - not the lines within it. Searches can match across lines, and can match line ending characters. </td></tr><tr><td><tt>M</tt></td><td>When mixed mode is set, the '^' and '$' anchors match the start and end respectively of each line, as if line mode is set, but in all other respects behaviour is as if document mode is set - the entire input document is processed in a single block.</td></tr></table><h4>Examples:</h4><pre>      ('$' ⎕R '[Endline]' ⍠ 'Mode' 'L') 'ABC' 'DEF'
        ABC[Endline]  DEF[Endline]
        
      ('$' ⎕R '[Endline]' ⍠ 'Mode' 'D') 'ABC' 'DEF'
 ABC  DEF[Endline
        
      ('$' ⎕R '[Endline]' ⍠ 'Mode' 'M') 'ABC' 'DEF'
 ABC[Endline]  DEF[Endline]</pre><h4>DotAll Option</h4><p>Specifies whether the dot (‘.’) character in search patterns matches line ending characters. </p><table><tr><td class="DefaultOption">0                 </td><td>The ‘.’ character in search patterns matches most characters, but not line endings.</td></tr><tr><td><tt>1</tt></td><td>The ‘.’ character in search patterns matches all characters.</td></tr></table><p>This option is invalid in line mode, because line endings are stripped from the input document.</p><h4>Example:</h4><pre>      ('.' ⎕R 'X' ⍠'Mode' 'D') 'ABC' 'DEF'
 XXX  XXX 
      ('.' ⎕R 'X' ⍠('Mode' 'D')('DotAll' 1)) 'ABC' 'DEF'
 XXXXXXXX
</pre><h4>EOL Option</h4><p>Sets the line ending character which is implicitly present between character vectors, when the input document is a vector of character vectors. </p><table><tr><td>CR </td><td>Carriage Return (U+000D)</td></tr><tr><td>LF</td><td>Line Feed (U+000A)</td></tr><tr><td class="DefaultOption">CRLF</td><td>Carriage Return followed by New Line</td></tr><tr><td>VT</td><td>Vertical Tab (U+000B)</td></tr><tr><td>NEL</td><td>New Line (U+0085)</td></tr><tr><td>FF</td><td>Form Feed (U+000C)</td></tr><tr><td>LS</td><td>Line Separator (U+2028)</td></tr><tr><td>PS</td><td>Paragraph Separator (U+2029)</td></tr></table><p>In the Classic Edition, setting a value which is not in <tt>⎕AVU</tt> may result in a <tt>TRANSLATION ERROR</tt>.</p><h4>Example:</h4><pre>      ('\n' ⎕R'X' ⍠('Mode' 'D')('EOL' 'LF')) 'ABC' 'DEF'
 ABCXDEF
</pre><p>Here, the implied line ending between ‘ABC’ and ‘DEF’ is ‘\n’, not the default ‘\r\n’.</p><h4>NEOL Option</h4><p>Specifies whether explicit line ending sequences in the input document are normalised by replacing them with the character specified using the <b>EOL</b> option. </p><table><tr><td class="DefaultOption">0 </td><td>Line endings are not normalised.</td></tr><tr><td>1</td><td>Line endings are normalised.</td></tr></table><h4>Example:</h4><pre>      a←'ABC',(1↑2↓⎕AV),'DEF',(1↑3↓⎕AV),'GHI'
      ('\n'⎕S 0 ⍠ 'Mode' 'D' ⍠ 'NEOL' 1 ⍠ 'EOL' 'LF') a
3 7
</pre><p>‘\n’ has matched both explicit line ending characters in the input, even though they are different.</p><h4>ML Option</h4><p>Sets a limit to the number of processed pattern matches per line (line mode) or document (document mode and mixed mode). </p><table><tr><td>Positive value n</td><td>Sets the limit to the first n matches. </td></tr><tr><td class="DefaultOption">0 </td><td>Sets no limit.</td></tr><tr><td>Negative value <tt>¯</tt>n</td><td>Sets the limit to exactly the nth match.</td></tr></table><h4>Examples:</h4><pre>      ('.' ⎕R 'x' ⍠ 'ML' 2) 'ABC' 'DEF'
 xxC  xxF 
      ('.' ⎕R 'x' ⍠ 'ML' ¯2) 'ABC' 'DEF'
 AxC  DxF 
      ('.' ⎕R 'x' ⍠ 'ML' ¯4 ⍠ 'Mode' 'D') 'ABC' 'DEF'
 ABC  xEF
</pre><h4>Greedy Option</h4><p>Controls whether patterns are “greedy” (and match the maximum input possible) or are not (and match the minimum). Within the pattern itself it is possible to specify greediness for individual elements of the pattern; this option sets the default. </p><table><tr><td class="DefaultOption">1 </td><td>Greedy by default.</td></tr><tr><td>0</td><td>Not greedy by default.</td></tr></table><h4>Examples:</h4><pre>      ('[A-Z].*[0-9]' ⎕R 'X' ⍠ 'Greedy' 1)'ABC123 DEF456'
X
      ('[A-Z].*[0-9]' ⎕R 'X' ⍠ 'Greedy' 0)'ABC123 DEF456'
X23 X56
</pre><h4>OM Option</h4><p>Specifies whether matches may overlap.</p><table><tr><td>1 </td><td>Searching continues for all patterns and then from the character following the <span class="Italic">start</span> of the match, thus permitting overlapping matches.</td></tr><tr><td class="DefaultOption">0 </td><td>Searching continues from the character following the <span class="Italic">end</span> of the match.</td></tr></table><p>This option may only be used with <tt>⎕S</tt>. With <tt>⎕R</tt> searching always continues from the character following the end of the match (the characters following the start of the match will have been changed). </p><h4>Examples:</h4><pre>      ('[0-9]+' ⎕S '\0' ⍠ 'OM' 0) 'A 1234 5678 B'
 1234  5678 
      ('[0-9]+' ⎕S '\0' ⍠ 'OM' 1) 'A 1234 5678 B'
 1234  234  34  4  5678  678  78  8
</pre><h4>InEnc Option</h4><p>This option specifies the encoding of the input stream when it cannot be determined automatically. </p><p>When the stream is read from its start, and the start of the stream contains a recognised Byte Order Mark (BOM), the encoding is taken as that specified by the BOM and this option is ignored. Otherwise, the encoding is assumed to be as specified by this option.</p><table><tr><td class="DefaultOption">UTF8</td><td>The stream is processed as UTF-8 data. Note that ASCII is a subset of UTF-8, so this default is also suitable for ASCII data.</td></tr><tr><td>UTF16LE</td><td>The stream is processed as UTF16 little-endian data.</td></tr><tr><td>UTF16BE</td><td>The stream is processed as UTF16 big-endian data.</td></tr><tr><td>ASCII</td><td>The stream is processed as ASCII data. If the stream contains any characters outside of the ASCII range then an error is produced. </td></tr><tr><td>ANSI</td><td>The stream is processed as ANSI (Windows-1252) data.</td></tr></table><p>For compatibility with the <b>OutEnc</b> option, the above UTF formats may be qualified with -BOM (e.g. UTF-BOM). For input streams, the qualified and unqualified options are equivalent.</p><h4>OutEnc Option</h4><p>When the output is written to a stream, the data may be encoded on one of the following forms: </p><table><tr><td class="DefaultOption">Implied </td><td>If input came from a stream then the encoding format is the same as the input stream, otherwise UTF-8</td></tr><tr><td>UTF8</td><td>The data is written in UTF-8 format.</td></tr><tr><td>UTF16LE</td><td>The data is written in UTF-16 little-endian format.</td></tr><tr><td>UTF16BE</td><td>The data is written in UTF-16 big-endian format.</td></tr><tr><td>ASCII</td><td>The data is written in ASCII format.</td></tr><tr><td>ANSI</td><td>The data is written in ANSI (Windows-1252) format.</td></tr></table><p>The above UTF formats may be qualified with -BOM (e.g. UTF8-BOM) to specify that a Byte Order Mark should be written at the start of the stream. For files, this is ignored if the file already contains any data.</p><h4>Enc Option</h4><p>This option sets both <b>InEnc</b> and <b>OutEnc</b> simultaneously, with the same given value. Any option value accepted by those options except Implied may be given. </p><h4>ResultText Option</h4><p>For <tt>⎕R</tt>, this option determines the format of the result.</p><table><tr><td class="DefaultOption">Implied</td><td>The output will either be a <b>character vector</b> or <b>a vector of character vectors</b>, dependent on the input document type</td></tr><tr><td>Simple</td><td>The output will be a <b>character vector</b>. Any and all line endings in the output will be represented by line ending characters within the character vector.</td></tr><tr><td>Nested</td><td>The output will be a <b>vector of character vectors</b>. Any and all line endings in the output document will be implied at the end of each character vector.  </td></tr></table><p>This option may only be used with <tt>⎕R</tt>.</p><p>Examples:</p><pre>      ⎕UCS ¨ ('A' ⎕R 'x') 'AB' 'CD'                
  120 66  67 68                    
      ⎕UCS ('A' ⎕R 'x' ⍠ 'ResultText' 'Simple') 'AB' 'CD'
 120 66 13 10 67 68
</pre><h4>Line, document and mixed modes</h4><p>The Mode setting determines how the input document is packaged as a block and passed to the search engine. In line mode each line is processed separately; in document mode and mixed mode the entire document is presented to the search engine. This affects both the semantics of the search expression, and memory usage.</p><h4>Semantic differences</h4><ul><li value="1">The <b>ML</b> option applies per block of data.</li><li value="2">In line mode, search patterns cannot be constructed to span multiple lines. Specifically, patterns that include line ending characters (such as ‘\r’) will never match because the line endings are never presented to the search engine.</li><li value="3">By default the search pattern metacharacters ‘^’ and ‘$’ match the start and end of the block of data. In line mode this is always the start and end of each line. In document mode this is the start and end of the document. In mixed mode the behaviour of ‘^’ and ‘$’ are amended by setting the PCRE option ‘MULTILINE’ so that they match the start and end of each line within the document.</li></ul><h4>Memory usage differences</h4><ul><li value="1">Blocks of data passed to the search engine are processed and stored in the workspace. Processing the input document in line mode limits the total memory requirements; in particular this means that large streams can be processed without holding all the data in the workspace at the same time.</li></ul><h4>Technical Considerations</h4><p><tt>⎕R</tt> and <tt>⎕S</tt> utilise the open-source regular-expression search engine PCRE, which is built into the Dyalog software and distributed according to the PCRE license which is published separately.</p><p>Before data is passed to PCRE it is converted to UTF-8 format. This converted data is buffered in the workspace; processing large documents may have significant memory requirements. In line mode, the data is broken into individual lines and each is processed separately, potentially reducing memory demands.</p><p>It is possible to save a workspace with an active <tt>⎕R</tt> or <tt>⎕S</tt> on the stack and execution can continue when the workspace is reloaded with the same interpreter version. Later versions of the interpreter may not remain compatible and may signal a <tt>DOMAIN ERROR</tt> with explanatory message in the status window if it is unable to continue execution.</p><p>PCRE has a buffer length limit of 2<sup>31</sup> bytes (2GB). UTF-8 encodes each character using between 1 and 6 bytes (typically 1 or 3). In the very worst case, where every character is encoded in 6 bytes, the maximum block length which can be searched would be 357,913,940 characters.</p><h4>Further Examples</h4><p>Several of the examples use the following vector as the input document:</p><pre>      text
To be or not to be– that is the question:
Whether 'tis nobler in the mind to suffer
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles</pre><h4>Replace all upper and lower-case vowels by <tt>'X'</tt>:</h4><pre>       ('[aeiou]' ⎕R 'X' ⍠ 'IC' 1) text
TX bX Xr nXt tX bX– thXt Xs thX qXXstXXn:   
WhXthXr 'tXs nXblXr Xn thX mXnd tX sXffXr   
ThX slXngs Xnd XrrXws Xf XXtrXgXXXs fXrtXnX,
Xr tX tXkX Xrms XgXXnst X sXX Xf trXXblXs   </pre><h4>Replace only the second vowel on each line by <tt>'\VOWEL\'</tt>:</h4><pre>       ('[aeiou]' ⎕R '\\VOWEL\\'⍠('IC' 1)('ML' ¯2)) text
To b\VOWEL\ or not to be– that is the question:   
Wheth\VOWEL\r 'tis nobler in the mind to suffer   
The sl\VOWEL\ngs and arrows of outrageous fortune,
Or t\VOWEL\ take arms against a sea of troubles</pre><h4>Case fold each word:</h4><pre>      ('(?&lt;first&gt;\w)(?&lt;remainder&gt;\w*)' ⎕R '\u&lt;first&gt;\l&lt;remainder&gt;') text
To Be Or Not To Be– That Is The Question:   
Whether 'Tis Nobler In The Mind To Suffer   
The Slings And Arrows Of Outrageous Fortune,
Or To Take Arms Against A Sea Of Troubles   </pre><h4>Extract only the lines with characters ‘or’ (in upper or lower case) on them:</h4><pre>      ↑('or' ⎕S '%' ⍠ ('IC' 1)('ML' 1)) text
To be or not to be– that is the question:   
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles </pre><h4>Identify which lines contain the word ‘or’ (in upper or lower case) on them:</h4><pre>      ('\bor\b'⎕S 2⍠('IC' 1)('ML' 1))text
0 3
</pre><p>Note the difference between the characters <span class="Italic">‘or’</span> (which appear in ‘fortune’) and the word <span class="Italic">‘or’</span>.</p><h4>Place every non-space sequence of characters in brackets:</h4><pre>      ('[^\s]+' ⎕R '(&amp;)' ) 'To be or not to be, that is the question'
(To) (be) (or) (not) (to) (be,) (that) (is) (the) (question)</pre><h4>Replace all sequences of one or more spaces by newline. Note that the effect of this is dependent on the input format:</h4><p>Character vector input results in a single character vector output with embedded newlines:</p><pre>      ]display ('\s+' ⎕R '\r') 'To be or not to be, that is the question'
┌→───────┐
│To      │
│be      │
│or      │
│not     │
│to      │
│be,     │
│that    │
│is      │
│the     │
│question│
└────────┘
</pre><p>A vector of two character vectors as input results in a vector of 10 character vectors output:</p><pre class="APLCodeSmall">      ]display ('\s+' ⎕R '\r') 'To be or not to be,' 'that is the question'
┌→─────────────────────────────────────────────────────────────┐
│ ┌→─┐ ┌→─┐ ┌→─┐ ┌→──┐ ┌→─┐ ┌→──┐ ┌→───┐ ┌→─┐ ┌→──┐ ┌→───────┐ │
│ │To│ │be│ │or│ │not│ │to│ │be,│ │that│ │is│ │the│ │question│ │
│ └──┘ └──┘ └──┘ └───┘ └──┘ └───┘ └────┘ └──┘ └───┘ └────────┘ │
└∊─────────────────────────────────────────────────────────────┘
</pre><h4>Change numerals to their expanded names, using a function:</h4><pre>     ∇r←f a                                                                                                     
[1]   r←' ',⊃(⍎a.Match)↓'zero' 'one' 'two' 'three' 'four'
                      'five' 'six' 'seven' 'eight' 'nine'                   
     ∇
      verbose←('[0-9]' ⎕R f)
      verbose ⍕27×56×87
 one three one five four four</pre><h4>Swap ‘red’ and ‘blue’:</h4><pre>      ('red' 'blue' ⎕R 'blue' 'red') 'red hat blue coat'
blue hat red coat</pre><h4>Convert a comma separated values (CSV) file so that</h4><ul><li value="1">dates in the first field are converted from European format to ISO, and</li><li value="2">currency values are converted from Deutsche Marks (DEM) to Euros (DEM 1.95583 to €1).</li></ul><p>The currency conversion requires the use of a function. Note the nested use of <tt>⎕R</tt>.</p><p>Input file:</p><table><tr style="height: 60pt;"><td><span class="Code">01/03/1980,Widgets,DEM 10.20</span><br style="mc-tag-and-class: span;" /><span class="Code">02/04/1980,Bolts,DEM 61.75</span><br style="mc-tag-and-class: span;" /><span class="Code">17/06/1980,Nuts; special rate DEM 17.00,DEM 17.00</span><br style="mc-tag-and-class: span;" /><span class="Code">18/07/1980,Hammer,DEM 1.25</span></td></tr></table><p>Output file:</p><table><tr style="height: 60pt;"><td><span class="Code">1980-03-01,Widgets,€ 5.21</span><br style="mc-tag-and-class: span;" /><span class="Code">1980-04-02,Bolts,€ 31.57</span><br style="mc-tag-and-class: span;" /><span class="Code">1980-06-17,Nuts; special rate DEM 17.00,€ 8.69</span><br style="mc-tag-and-class: span;" /><span class="Code">1980-07-18,Hammer,€ 0.63</span></td></tr></table><pre>     ∇ ret←f a;d;m;y;v
[1]    ⎕IO←0
[2]    :Select a.PatternNum
[3]    :Case 0
[4]        d m y←{a.Match[a.Offsets[⍵+1]+⍳a.Lengths[⍵+1]]}¨⍳3
[5]        ret←y,'-',m,'-',d,','
[6]    :Else
[7]        v←⍎a.Block[a.Offsets[1]+⍳a.Lengths[1]]
[8]        v÷←1.95583
[9]        ret←',€ ',('(\d+\.\d\d).*'⎕R'\1')⍕v
[10]   :EndSelect
     ∇</pre><pre>      in ← 'x.csv' ⎕NTIE 0
      out ← 'new.csv' ⎕NCREATE 0
      dateptn←'(\d{2})/(\d{2})/(\d{4}),'
      valptn←',DEM ([0-9.]+)'
      out (dateptn valptn ⎕R f) in
      ⎕nuntie¨in out</pre><h4>Create a simple profanity filter. For the list of objectionable words:</h4><pre>       profanity←'bleeding' 'heck'</pre><p>first construct a pattern which will match the words:</p><pre>      ptn←(('^' '$' '\r\n') ⎕R '\\b(' ')\\b' '|'
                           ⎕OPT 'Mode' 'D') profanity
      ptn
\b(bleeding|heck)\b</pre><p>then a function that uses this pattern:</p><pre>      sanitise←ptn ⎕R '****' ⎕opt 1
      sanitise '"Heck", I said'
"****", I said</pre><script src="../../../help.js"></script></body>
</html>