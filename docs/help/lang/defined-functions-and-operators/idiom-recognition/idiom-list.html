<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../../help.css"></head>
<body><h3>Idiom List</h3><p>In the following table, arguments to the idiom have types and ranks as follows:</p><table><tr><th class="Left">Type</th><th class="Left">Description</th><th class="Left">Rank</th><th class="Left">Description</th></tr><tr><td>C</td><td>Character</td><td>S</td><td>Scalar or 1-item vector</td></tr><tr><td>B</td><td>Boolean</td><td>V</td><td>Vector</td></tr><tr><td>N</td><td>Numeric</td><td>M</td><td>Matrix</td></tr><tr><td>P</td><td>Nested</td><td>A</td><td>Array of any rank</td></tr><tr><td>X</td><td>any type</td><td> </td><td> </td></tr></table><p>For example: NV: numeric vector, CM: character matrix, PV: nested vector.</p><table><tr><th class="Left">Idiom</th><th class="Left">Description</th></tr><tr><td><tt>⍴⍴XA</tt></td><td>The rank of <tt>XA</tt></td></tr><tr><td><tt>BV/⍳NS</tt></td><td>The subset of <tt>NS</tt> corresponding to the 1s in <tt>BV</tt></td></tr><tr><td><tt>BV/⍳⍴XV</tt></td><td>The positions in <tt>XV</tt> corresponding to the 1s in <tt>BV</tt></td></tr><tr><td><tt>NA⊃¨⊂XV</tt></td><td>The subset of <tt>XV</tt> in the index positions defined by <tt>NA</tt> (equivalent to <tt>XV[NA]</tt>)</td></tr><tr><td><tt>XA1{}XA2</tt></td><td><tt>XA1</tt> and <tt>XA2</tt> are ignored (no result produced)</td></tr><tr><td><tt>XA1{⍺}XA2</tt></td><td><tt>XA1</tt> (<tt>XA2</tt> is ignored)</td></tr><tr><td><tt>XA1{⍵}XA2</tt></td><td><tt>XA2</tt> (<tt>XA1</tt> is ignored)</td></tr><tr><td><tt>XA1{⍺ ⍵}XA2</tt></td><td><tt>XA1</tt> and <tt>XA2</tt> as a two item vector <tt>(XA1 XA2)</tt></td></tr><tr><td><tt>{0}XA</tt></td><td>0 irrespective of <tt>XA</tt></td></tr><tr><td><tt>{0}¨XA</tt></td><td>0 corresponding to each item of <tt>XA</tt></td></tr><tr><td><tt>,/PV</tt></td><td>The enclose of the items of <tt>PV</tt> (which must be of depth 2) catenated along their last axes</td></tr><tr><td><tt>⍪/PV</tt></td><td>The enclose of the items of <tt>PV</tt> (which must be of depth 2) catenated along their first axes</td></tr><tr><td><tt>⊃⌽XA</tt></td><td>The item in the top right of <tt>XA</tt> (<tt>⎕ML&lt;2</tt>)</td></tr><tr><td><tt>↑⌽XA</tt></td><td>The item in the top right of <tt>XA</tt> (<tt>⎕ML≥2</tt>)</td></tr><tr><td><tt>⊃⌽,XA</tt></td><td>The item in the bottom right of <tt>XA</tt> (<tt>⎕ML&lt;2</tt>)</td></tr><tr><td><tt>↑⌽,A</tt></td><td>The item in the bottom right of <tt>XA</tt> (<tt>⎕ML≥2</tt>)</td></tr><tr><td><tt>0=⍴XV</tt></td><td>1 if <tt>XV</tt> has a shape of zero, 0 otherwise</td></tr><tr><td><tt>0=⍴⍴XA</tt></td><td>1 if <tt>XA</tt> has a rank of zero (scalar), 0 otherwise</td></tr><tr><td><tt>0=≡XA</tt></td><td>1 if <tt>XA</tt> has a depth of zero (simple scalar), 0 otherwise</td></tr><tr><td><tt>XM1{(↓⍺)⍳↓⍵}XM2</tt></td><td>A simple vector comprising as many items as there are rows in <tt>XM2</tt>, where each item is the number of the first row in <tt>XM1</tt> that matches each row in <tt>XM2</tt>.</td></tr><tr><td><tt>↓⍉↑PV</tt></td><td>A nested vector comprising vectors that each correspond to a position in the original vectors of <tt>PV</tt> – the first vector contains the first item from each vector in <tt>PV</tt>, padded to be the same length as the largest vector, and so on (<tt>⎕ML&lt;2</tt>)</td></tr><tr><td><tt>↓⍉⊃PV</tt></td><td>A nested vector comprising vectors that each correspond to a position in the original vectors of <tt>PV</tt> – the first vector contains the first item from each vector in <tt>PV</tt>, padded to be the same length as the largest vector, and so on (<tt>⎕ML≥2</tt>)</td></tr><tr><td><tt>^\' '=CA</tt></td><td>A Boolean mask indicating the leading blank spaces in each row of <tt>CA</tt></td></tr><tr><td><tt>+/^\' '=CA</tt></td><td>The number of leading blank spaces in each row of <tt>CA</tt></td></tr><tr><td><tt>+/^\BA</tt></td><td>The number of leading 1s in each row of <tt>BA</tt></td></tr><tr><td><tt>{(∨\' '≠⍵)/⍵}CV</tt></td><td><tt>CV</tt> without any leading blank spaces</td></tr><tr><td><tt>{(+/^\' '=⍵)↓⍵}CV</tt></td><td><tt>CV</tt> without any leading blank spaces</td></tr><tr><td><tt>~∘' '¨↓CA</tt></td><td>A nested vector comprising simple character vectors constructed from the rows of <tt>CA</tt> (which must be of depth 1) with all blank spaces removed</td></tr><tr><td><tt>{(+/∨\' '≠⌽⍵)↑¨↓⍵}CA</tt></td><td>A nested vector comprising simple character vectors constructed from the rows of <tt>CA</tt> (which must be of depth 1) with trailing blank spaces removed</td></tr><tr><td><tt>⊃∘⍴¨XA</tt></td><td>The length of the first axis of each item in <tt>XA</tt> (<tt>⎕ML&lt;2</tt>)</td></tr><tr><td><tt>↑∘⍴¨XA</tt></td><td>The length of the first axis of each item in <tt>XA</tt> (<tt>⎕ML≥2</tt>)</td></tr><tr><td><tt>XA1,←XA2</tt></td><td><tt>XA1</tt> redefined to be <tt>XA1</tt> with <tt>XA2</tt> catenated along its last axis</td></tr><tr><td><tt>XA1⍪←XA2</tt></td><td><tt>XA1</tt> redefined to be <tt>XA1</tt> with <tt>XA2</tt> catenated along its first axis</td></tr><tr><td><tt>{⍵[⍋⍵]}XV</tt></td><td><tt>XV</tt> sorted into numerical or alphabetical order</td></tr><tr><td><tt>{⍵[⍒⍵]}XV</tt></td><td><tt>XV</tt> sorted into reverse numerical or alphabetical order</td></tr><tr><td><tt>{⍵[⍋⍵;]}XM</tt></td><td><tt>XM</tt> with the rows sorted into numerical or alphabetical order</td></tr><tr><td><tt>{⍵[⍒⍵;]}XM</tt></td><td><tt>XM</tt> with the rows sorted into reverse numerical or alphabetical order</td></tr><tr><td><tt>1=≡XA
                </tt></td><td>1 if <tt>XA</tt> has a depth of 1 (simple array), 0 otherwise</td></tr><tr><td><tt>1=≡,XA
                </tt></td><td>1 if <tt>XA</tt> has a depth of 0 or 1 (simple scalar, vector, etc.), 0 otherwise</td></tr><tr><td><tt>0∊⍴XA
                </tt></td><td>1 if <tt>XA</tt> is empty, 0 otherwise</td></tr><tr><td><tt>~0∊⍴XA
                </tt></td><td>1 if <tt>XA</tt> is not empty, 0 otherwise</td></tr><tr><td><tt>⊣⌿XA
                </tt></td><td>The first sub-array along the first axis of <tt>XA</tt></td></tr><tr><td><tt>⊣/XA
                </tt></td><td>The first sub-array along the last axis of <tt>XA</tt></td></tr><tr><td><tt>⊢⌿XA
                </tt></td><td>The last sub-array along the first axis of <tt>XA</tt></td></tr><tr><td><tt>⊢/XA
                </tt></td><td>The last sub-array along the last axis of <tt>XA</tt></td></tr><tr><td><tt>*○NA
                </tt></td><td>Euler's idiom (accurate when <tt>NA</tt> is a multiple of <tt>0J0.5)</tt></td></tr><tr><td><tt>0=⊃⍴</tt></td><td>1 if <tt>XA</tt> has an empty first dimension, 0 otherwise (<tt>⎕ML&lt;2</tt>)</td></tr><tr><td><tt>0≠⊃⍴</tt></td><td>1 if <tt>XA</tt> does not have an empty first dimension, 0 otherwise (<tt>⎕ML&lt;2</tt>)</td></tr><tr><td><tt>⎕AV⍳CA</tt></td><td>Classic version only: The character numbers (atomic vector index) corresponding to the characters in <tt>CA</tt></td></tr><tr><td><tt>⌊0.5+NA</tt></td><td>Round to nearest integer</td></tr></table><h4>Notes</h4><p style="font-family: 'Times New Roman';"><tt>/⍳</tt> and <tt>/⍳⍴</tt>, as well as providing an execution time advantage, reduce intermediate workspace usage and, consequently, the incidence of memory compactions and the likelihood of a <tt>WS FULL</tt>.</p><p style="font-family: 'Times New Roman';"><tt>NA⊃¨⊂XV</tt> is implemented as <tt>XV[NA]</tt>, which is significantly faster. The two are equivalent but the former now has no performance penalty.</p><p style="font-family: 'Times New Roman';"><tt>,/</tt> is special-cased only for vectors of vectors or scalars. Otherwise, the expression is evaluated as a series of concatenations. Recognition of this idiom turns <b>join</b> from an <span class="Italic">n-squared</span> algorithm into a linear one. In other words, the improvement factor is proportional to the size of the argument vector.</p><p style="font-family: 'Times New Roman';"><tt>⊃⌽</tt> and <tt>⊃⌽,</tt> now take constant time. Without idiom recognition, the time taken depends linearly on the number of items in the argument.</p><p style="font-family: 'Times New Roman';"><tt>0=≡</tt> takes a small constant time. Without idiom recognition, the time taken would depend on the size and depth of the argument, which in the case of a deeply nested array could be significant.</p><p style="font-family: 'Times New Roman';"><tt>↓⍉↑</tt> is special-cased only for a vector of nested vectors, each of whose items is of the same length.</p><p><tt>{(↓⍺)⍳↓⍵}</tt> can accommodate much larger matrices than its constituent primitives. It is particularly effective when bound with a left argument using the compose operator:</p><pre>      find←mat∘{(↓⍺)⍳↓⍵}     ⍝ find rows in mat table</pre><p>In this case, the internal hash table for <tt>mat</tt> is retained so that it does not need to be generated each time the monadic derived function <tt>find</tt> is applied to a matrix argument.</p><p><tt>{(∨\' '≠⍵)/⍵}</tt> and <tt>{(+/^\' '=⍵)↓⍵}</tt> are two codings of the same idiom. Both use the same C code for evaluation.</p><p><tt>~∘' '¨↓</tt> typically takes a character matrix argument and returns a vector of character vectors from which all blanks have been removed. An example might be the character matrix of names returned by the system function <tt>⎕NL</tt>. In general, this idiom accommodates character arrays of any rank.</p><p><tt>{(+/∨\' '≠⌽⍵)↑¨↓⍵}</tt> typically takes a character matrix argument and returns a vector of character vectors. Any embedded blanks in each row are preserved but trailing blanks are removed. In general, this idiom accommodates character arrays of any rank.</p><p><tt>⊃∘⍴¨A</tt> (<tt>⎕ML&lt;2</tt>) and <tt>↑∘⍴¨A</tt> (<tt>⎕ML&gt;2</tt>) avoid having to create an intermediate nested array of shape vectors.</p><p>For an array of vectors, this idiom quickly returns a <span class="Italic">simple array</span> of the length of each vector.</p><pre>      ⊃∘⍴¨ 'Hi' 'Pete' ⍝ Vector Lengths
2 4</pre><p>For an array of matrices, it returns a simple array of the number of rows in each matrix.</p><pre>      ⊃∘⍴¨⎕CR¨↓⎕NL 3   ⍝ Lines in functions
5 21...</pre><p><tt>A,←A</tt> and <tt>A⍪←A</tt>optimise the catenation of an array to another array along the last and first dimension respectively.</p><p>Among other examples, this idiom optimises repeated catenation of a scalar or vector to an existing vector.</p><pre>      props,←⊂ 'Posn' 0 0
      props,←⊂'Size' 50 50
      vector,←2+4</pre><p>Note that the idiom is not applied if the value of vector <tt>V</tt> is shared with another symbol in the workspace, as illustrated in the following examples:</p><p>Example 1: the idiom is used to perform the catenation to <tt>V1</tt>.</p><pre>      V1←⍳10
      V1,←11</pre><p>Example 2: the idiom is not used to perform the catenation to <tt>V1</tt>, because its value is at that point shared with <tt>V2</tt>.</p><pre>      V1←⍳10
      V2←V1
      V1,←11</pre><p>Example 3: the idiom is not used to perform the catenation to <tt>V</tt> in <tt>Join[1]</tt> because its value is, at that point, shared with the array used to call the function.</p><pre>     ∇ V←V Join A
[1]    V,←A
     ∇
      (⍳10) Join 11
1 2 3 4 5 6 7 8 9 10 11</pre><p><tt>⊢⌿XA</tt>, <tt>⊢/XA</tt>, <tt>⊣⌿XA</tt>, and <tt>⊣/XA</tt> return the first/last rank <tt>(0⌈¯1+⍴⍴A)</tt> sub-array along the first/last axis of <tt>XA</tt>. For example, if <tt>V</tt> is a vector, then:</p><table><tr><td><tt>⊣/V</tt></td><td>First item of vector</td></tr><tr><td><tt>⊢/V</tt></td><td>Last item of vector</td></tr></table><p>Similarly, if <tt>M</tt> is a matrix, then:</p><table><tr><td><tt>⊣⌿M</tt></td><td>First row of matrix</td></tr><tr><td><tt>⊣/M</tt></td><td>First column of matrix</td></tr><tr><td><tt>⊢⌿M</tt></td><td>Last row of matrix</td></tr><tr><td><tt>⊢/M</tt></td><td>Last column of matrix</td></tr></table><p>The idiom generalises uniformly to higher-rank arrays.</p><p><b>Euler's idiom</b><tt>*○NA</tt> produces accurate results for right argument values that are a multiple of <tt>0J0.5</tt>. This is so that Euler's famous identity <tt>0=1+*○0J1</tt> holds, despite pi being represented as a floating point number.</p></body>
</html>