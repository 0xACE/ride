<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../../help.css"></head>
<body><h3>Globals and the Order of Execution</h3><p>It is important to recognise that any reference or assignment to a global or semi-global object (including GUI objects) is <b>inherently dangerous</b> (i.e. a source of programming error) if more than one thread is running. Worse still, programming errors of this sort may not become apparent during testing because they are dependent upon random timing differences. Consider the following example:</p><pre>     ∇ BUG;SEMI_GLOBAL
[1]    SEMI_GLOBAL←0
[2]    FOO&amp; 1
[3]    GOO&amp; 1
     ∇
 
     ∇ FOO
[1]    :If SEMI_GLOBAL=0
[2]        DO_SOMETHING SEMI_GLOBAL
[3]    :Else
[4]        DO_SOMETHING_ELSE SEMI_GLOBAL
[5]    :EndIf
     ∇
 
     ∇ GOO
[1]    SEMI_GLOBAL←1
     ∇</pre><p>In this example, it is formally impossible to predict in which order APL will execute statements in <tt>BUG</tt>, <tt>FOO</tt> or <tt>GOO</tt> from <tt>BUG[2]</tt> onwards. For example, the actual sequence of execution may be:</p><pre>      BUG[1] → BUG[2] → FOO[1] → FOO[2] →
               DO_SOMETHING[1]</pre><p>or</p><pre>      BUG[1] → BUG[2] → BUG[3] → GOO[1] →
               FOO[1] → FOO[2] → FOO[3] →
               FOO[4] → DO_SOMETHING_ELSE[1]</pre><p>This is because APL may switch from one thread to another between any two lines in a defined function. In practice, because APL gives each thread a significant time-slice, it is likely to execute many lines, maybe even hundreds of lines, in one thread before switching to another. However, you must not rely on this; <b>thread-switching may occur at any time between lines in a defined function</b>.</p><p>Secondly, consider the possibility that APL switches from the <tt>FOO</tt> thread to the <tt>GOO</tt> thread after <tt>FOO[1]</tt>. If this happens, the value of <tt>SEMI_GLOBAL</tt> passed to <tt>DO_SOMETHING</tt> will be 1 and not 0. Here is another source of error.</p><p>In fact, in this case, there are two ways to resolve the problem. To ensure that the value of <tt>SEMI_GLOBAL</tt> remains the same from <tt>FOO[1]</tt> to <tt>FOO[2]</tt>, you may use diamonds instead of separate statements, e.g.</p><pre>      :If SEMI_GLOBAL=0 ⋄ DO_SOMETHING SEMI_GLOBAL</pre><p>Even better, although less efficient, you may use <tt>:Hold</tt> to synchronise access to the variable, for example:</p><pre>      ∇ FOO
[1]    :Hold 'SEMI_GLOBAL'
[2]        :If SEMI_GLOBAL=0
[3]            DO_SOMETHING SEMI_GLOBAL
[4]        :Else
[5]            DO_SOMETHING_ELSE SEMI_GLOBAL
[6]        :EndIf
[7]    :EndHold
     ∇
 
     ∇ GOO
[1]    :Hold 'SEMI_GLOBAL'
[2]        SEMI_GLOBAL←1
[3]    :EndHold
     ∇</pre><p>Now, although you still cannot be sure which of <tt>FOO</tt> and <tt>GOO</tt> will run first, you can be sure that <tt>SEMI_GLOBAL</tt> will not change (because <tt>GOO</tt> cuts in) within <tt>FOO</tt>.</p><p>Note that the string used as the argument to <tt>:Hold</tt> is completely arbitrary, so long as threads competing for the same resource use the same string.</p><h4>A Caution</h4><p>These types of problems are inherent in all multithreading programming languages, and not just with Dyalog APL. <span class="Italic" style="font-weight: bold; font-style: italic;">If you want to take advantage of the additional power provided by multithreading, it is advisable to think carefully about the potential interaction between different threads.</span></p></body>
</html>