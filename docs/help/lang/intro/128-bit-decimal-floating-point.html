<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><a name="128BitFloatingPointSupport"></a>128 Bit Decimal Floating-Point Support</h2><h3>Introduction</h3><p>The original IEE-754 64-bit binary floating point (FP) data type (also known as type number 645), that is used internally by Dyalog APL to represent floating-point values, does not have sufficient precision for certain financial computations – typically involving large currency amounts. The binary representation also causes errors to accumulate even when all values involved in a calculation are “exact” (rounded) decimal numbers, since many decimal numbers cannot be accurately represented regardless of the precision used to hold them. To reduce this problem, Dyalog APL includes support for the 128-bit decimal data type described by IEEE-754-2008 as an alternative representation for floating-point values.</p><h3>System Variable: <tt>⎕FR</tt></h3><p>Computations using 128-bit decimal numbers require twice as much space for storage, and run more than an order of magnitude more slowly on platforms which do not provide hardware support for the type. At this time, hardware support is only available from IBM (Power chips starting with the “P6”, and recent “z” series mainframes). Even with hardware support, a slowdown of a factor of 4 can be expected. For this reason, Dyalog allows users to decide whether they need the higher-precision decimal representation, or prefer to stay with the faster and smaller binary representation.</p><p>The system variable <tt>⎕FR</tt> (for Floating-point Representation) can be set to the value 645 (the installed default) to indicate 64-bit binary FP, or 1287 for 128-bit decimal FP. The default value of <tt>⎕FR</tt> is configurable.</p><p>Simply put, the value of <tt>⎕FR</tt> decides the type of the result of any floating-point calculation that APL performs. In other words, when entered into the session:</p><pre>     ⎕FR = ⎕DR 1.234 ⍝ Type of a floating-point constant
     ⎕FR = ⎕DR 3÷4   ⍝ Type of any floating-point result</pre><p><tt>⎕FR </tt>has workspace scope, and may be localised. If so, like most other system variables, it inherits its initial value from the global environment.</p><p><b>However:</b> Although <tt>⎕FR</tt><i>can</i> vary, the system is not designed to allow “seamless” modification during the running of an application and the dynamic alteration of <tt>⎕FR</tt> is not recommended. Strange effects may occur. For example, the type of a constant contained in a line of code (in a function or class), will depend on the value of <tt>⎕FR</tt><i>when the function is fixed</i>. Similarly, a constant typed into a line in the Session is evaluated using the value of <tt>⎕FR</tt> that pertained <b>before</b> the line is executed. Thus, it would be possible for the first line of code above to return 0, if it is in the body of a function. If the function was edited and while suspended and execution is resumed, the result would become 1. Also note:</p><pre>      ⎕FR←1287
      x←1÷3
 
      ⎕FR←645
      x=1÷3
1</pre><p>The decimal number has 17 more 3s. Using the tolerance which applies to binary floats (type 645), the numbers are equal. However, the “reverse” experiment yields 0, as tolerance is much narrower in the 128-bit universe:</p><pre>      ⎕FR←645
      x←1÷3
 
      ⎕FR←1287
      x=1÷3
0</pre><p>Since <tt>⎕FR</tt> can vary, it will be possible for a single workspace to contain floating-point values of both types (existing variables are not converted when <tt>⎕FR</tt> is changed). For example, an array that has just been brought into the workspace from external storage may have a different type from <tt>⎕FR</tt> in the current namespace. Conversion (if necessary) will only take place when a <span class="Italic">new</span> floating-point array is generated as the result of “a calculation”. The result of a computation returning a floating-point result will <span class="Italic">not</span> depend on the type of the arrays involved in the expression: <tt>⎕FR</tt> at the time when a computation is performed decides the result type, alone.</p><p>Structural functions generally do NOT change the type, for example:</p><pre>      ⎕FR←1287
      x←1.1 2.2 3.3
      
      ⎕FR←645
      ⎕dr x
1287
      ⎕dr 2↑x
1287</pre><p>128-bit decimal numbers not only have greater precision (roughly 34 decimal digits); they also have significantly larger range- from <tt>¯1E6145</tt> to <tt>1E6145</tt>. Loss of precision is accepted on conversion from 645 to 1287, but the magnitude of a number may make the conversion impossible, in which case a <tt>DOMAIN ERROR</tt> is issued:</p><pre>      ⎕FR←1287
      x←1E1000
      
      ⎕FR←645
      x+0
DOMAIN ERROR</pre><p>WARNING: The use of COMPLEX numbers when <tt>⎕FR</tt> is 1287 is not recommended, because:</p><ul><li value="1">any 128-bit decimal array into which a complex number is inserted or appended will be forced in its entirety into complex representation, potentially losing precision</li><li value="2">all comparisons are done using <tt>⎕DCT</tt> when <tt>⎕FR</tt> is 1287, and this is equivalent to 0 for complex numbers.</li></ul><h3>Conversion between Decimal and Binary</h3><p>Conversion of data from Binary to Decimal is logically equivalent to formatting, and the reverse conversion is equivalent to evaluating input. These operations are performed according to the same rules that are used when formatting (and evaluating) numbers with <tt>⎕PP</tt> set to 17 (guaranteeing that the decimal value can be converted back to the same binary bit pattern). Because the precision of decimal floating-point numbers is much higher, there will always be a large number of potential decimal values which map to the same binary number: As with formatting, the rule is that the SHORTEST decimal number which maps to a particular binary value will be used as its decimal representation.</p><p>Data in component files will be stored without conversion, and only converted when a computation happens. It should be stored in decimal form if it will repeatedly be used by application code in which <tt>⎕FR</tt>has the value 1287. Even in applications which use decimal floating point everywhere, reading old component files containing arrays of type 645, or receiving data via <tt>⎕NA</tt>, the .Net interface or other external sources, will allow binary floating-point values to enter the system and require conversion.</p><h3><tt>⎕DCT</tt> - Decimal Comparison Tolerance</h3><p>When <tt>⎕FR</tt>has the value 1287, the system variable <tt>⎕DCT</tt> will be used to specify comparison tolerance. The default value of <tt>⎕DCT</tt> is <tt>1E¯28</tt>, and the maximum value is <tt>2.3283064365386962890625E¯10</tt> (the value is chosen to avoid fuzzy comparison of 32-bit integers).</p><h3>Passing floating-point values using <tt>⎕NA</tt></h3><p><tt>⎕NA</tt> supports the data type “D” to represent the Densely Packed Decimal (DPD) form of 128-bit decimal numbers, as specified by the IEEE-754 2008 standard. Dyalog has decided to use DPD, which is the format used by IBM for hardware support, on ALL platforms, although “Binary Integer Decimal” (BID) is the format that Intel libraries use to implement software libraries to do decimal arithmetic. Experiments have shown that the performance of 128-bit DPD and BID libraries are very similar on Intel platforms. In order to avoid the added complication of having two internal representations, Dyalog has elected to go with the hardware format, which is expected to be adopted by future hardware implementations.</p><p>The support libraries for writing AP’s and DLL’s include new functions to extract the contents of a value of type D as a string or double-precision binary “float” – and convert data to D format.</p><h3>Decimal Floats and Microsoft.NET</h3><p>The Microsoft.NET framework contains a type named System.Decimal, which implements decimal floating-point numbers. However, it uses a different internal format from that defined by IEEE-754 2008.</p><p>Dyalog APL includes a Microsoft.NET class (called Dyalog.Dec128), which will perform arithmetic on data represented using the “Binary Integer Decimal” format. All computations performed by the Dyalog.Dec128 class will produce exactly the same results as if the computation was performed in APL. A “DCT” property allows setting the comparison tolerance to be used in comparisons, Ceiling/Floor, etc).</p><p>The Dyalog class is modelled closely after the existing System.Decimal type, providing the same methods (Add, Ceiling, Compare, CompareTo, Divide, Equals, Finalize, Floor, FromOACurrency, GetBits, GetHashCode, GetType, GetTypeCode, MemberwiseClone, Multiply, Negate, Parse, Remainder, Round, Subtract, To*, Truncate, TryParse) and operators (Addition, Decrement, Division, Equality, Explicit, GreaterThan, GreaterThanOrEqual, Implicit, Increment, Inequality, LessThan, LessThanOrEqual, Modulus, Multiply, Subtraction, UnaryNegation, UnaryPlus). </p><p>The “bridge” between Dyalog and .NET is able to cast floating-point numbers to or from System.Double, System.Decimal and Dyalog.Dec128 (and perform all other reasonable casts to integer types etc). Casting a Dyalog.Dec128 to or from strings will perform a “lossless” conversion.</p><p>The .Net type System.Int64 will now always be cast to a 128-bit decimal number when entering Dyalog APL, regardless of the setting of <tt>⎕FR</tt>. So long as no 64-bit arithmetic is performed on such a value, it will remain a 128-bit number and can be passed back to .Net without loss.</p></body>
</html>