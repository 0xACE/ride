<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><a name="ScalarFunctions"></a>Scalar Functions</h2><p>There is a class of primitive functions termed SCALAR FUNCTIONS.  This class is identified in <a href="#ScalarPrimitiveFunctions" class="MCXref_TableRef_0">Table 7</a> below. Scalar functions are <b>pervasive</b>, i.e. their properties apply at all levels of nesting.  Scalar functions have the following properties:</p><p class="TableCaption"><span class="autonumber"><span>Table 7: </span></span><a name="ScalarPrimitiveFunctions"></a>Scalar Primitive Functions</p><table><col></col><col></col><col></col><tr><th class="Left">Symbol</th><th class="Left">Monadic</th><th class="Left">Dyadic</th></tr><tr><td><tt>+</tt></td><td><a href="identity.html">Identity</a></td><td><a href="add.html">Plus (Add)</a></td></tr><tr><td><tt>-</tt></td><td><a href="negative.html">Negative</a></td><td><a href="subtract.html">Minus (Subtract)</a></td></tr><tr><td><tt>×</tt></td><td><a href="direction.html">Direction (Signum)</a></td><td><a href="multiply.html">Times (Multiply)</a></td></tr><tr><td><tt>÷</tt></td><td><a href="reciprocal.html">Reciproca</a>l</td><td><a href="divide.html">Divide</a></td></tr><tr><td><tt>|</tt></td><td><a href="magnitude.html">Magnitude</a></td><td><a href="residue.html">Residue</a></td></tr><tr><td><tt>⌊</tt></td><td><a href="floor.html">Floor</a></td><td><a href="minimum.html">Minimum</a></td></tr><tr><td><tt>⌈</tt></td><td><a href="ceiling.html">Ceiling</a></td><td><a href="maximum.html">Maximum</a></td></tr><tr><td><tt>*</tt></td><td><a href="exponential.html">Exponential</a></td><td><a href="power.html">Power</a></td></tr><tr><td><tt>⍟</tt></td><td><a href="natural-logarithm.html">Natural Logarithm</a></td><td><a href="logarithm.html">Logarithm</a></td></tr><tr><td><tt>○</tt></td><td><a href="pi-times.html">Pi Times</a></td><td><a href="circular.html">Circular</a></td></tr><tr><td><tt>!</tt></td><td><a href="factorial.html">Factorial</a></td><td><a href="binomial.html">Binomial</a></td></tr><tr><td><tt>~</tt></td><td><a href="not.html">Not</a></td><td>$</td></tr><tr><td><tt>?</tt></td><td><a href="roll.html">Roll</a></td><td>$</td></tr><tr><td><tt>∊</tt></td><td><a href="type.html">Type</a> (See <a href="enlist.html">Enlist</a>)</td><td>$</td></tr><tr><td><tt>^</tt></td><td> </td><td><a href="and-lowest-common-multiple.html">And</a></td></tr><tr><td><tt>∨</tt></td><td> </td><td><a href="or-greatest-common-divisor.html">Or</a></td></tr><tr><td><tt>⍲</tt></td><td> </td><td><a href="nand.html">Nand</a></td></tr><tr><td><tt>⍱</tt></td><td> </td><td><a href="nor.html">Nor</a></td></tr><tr><td><tt>&lt;</tt></td><td> </td><td><a href="less.html">Less</a></td></tr><tr><td><tt>≤</tt></td><td> </td><td><a href="less-or-equal.html">Less Or Equal</a></td></tr><tr><td><tt>=</tt></td><td> </td><td><a href="equal.html">Equal</a></td></tr><tr><td><tt>≥</tt></td><td> </td><td><a href="greater-or-equal.html">Greater Or Equal</a></td></tr><tr><td><tt>&gt;</tt></td><td> </td><td><a href="greater.html">Greater</a></td></tr><tr><td><tt>≠</tt></td><td> </td><td><a href="not-equal.html">Not Equal</a></td></tr><tr><td colspan="3">$ Dyadic form is not scalar</td></tr></table><h4>Monadic Scalar Functions</h4><ul><li value="1">The function is applied independently to each simple scalar in its argument.</li><li value="2">The function produces a result with a structure identical to its argument.</li><li value="3">When applied to an empty argument, the function produces an empty result.  With the exception of <tt>+</tt> and <tt>∊</tt>, the type of this result depends on the function, not on the type of the argument. By definition + and <tt>∊</tt> return a result of the same type as their arguments.</li></ul><h4>Example</h4><pre>      ÷2 (1 4)
0.5  1 0.25</pre><h4>Dyadic Scalar Functions</h4><ul><li value="1">The function is applied independently to corresponding pairs of simple scalars in its arguments.</li><li value="2">A simple scalar will be replicated to conform to the structure of the other argument.  If a simple scalar in the structure of an argument corresponds to a non-simple scalar in the other argument, then the function is applied between the simple scalar and the items of the non-simple scalar.  Replication of simple scalars is called SCALAR EXTENSION.</li><li value="3">A simple unit is treated as a scalar for scalar extension purposes.  A UNIT is a single element array of any rank.  If both arguments are simple units, the argument with lower rank is extended.</li><li value="4">The function produces a result with a structure identical to that of its arguments (after scalar extensions).</li><li value="5">If applied between empty arguments, the function produces a composite structure resulting from any scalar extensions, with type appropriate to the particular function.  (All scalar dyadic functions return a result of numeric type.)</li></ul><h4>Examples</h4><pre>      2 3 4 + 1 2 3
3 5 7
 
      2 (3 4) + 1 (2 3)
3  5 7
 
      (1 2) 3 + 4 (5 6)
 5 6  8 9

      10 × 2 (3 4)
20  30 40
 
      2 4 = 2 (4 6)
1  1 0

      (1 1⍴5) - 1 (2 3)
4  3 2

      1↑''+⍳0
0
       1↑(0⍴⊂' ' (0 0))×''
0  0 0</pre><p><b>Note:</b>  The Axis operator applies to all scalar dyadic functions.</p></body>
</html>