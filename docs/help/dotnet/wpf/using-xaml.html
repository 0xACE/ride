<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h3><a name="Using_XAML"></a>Using XAML</h3><p>The functions and data for this example are provided in the workspace <span class="Code">WPFINtro.dws</span> in the namespace <tt>WPF.UsingXAML</tt>. To run the example:</p><pre>      )LOAD WPFINtro<br />      WPF.UsingXAML.TempConverter</pre><p>Arguably the easiest way to create a WPF GUI is to define it using XAML. The XAML defines the structure, layout and appearance of the user-interface in a very concise manner. It is still necessary to write code to display the XAML and to respond to user actions, but the amount of code involved is minimal.</p><p> The XAML for the Temperature Converter is shown below.</p><pre class="Code">&lt;Window
 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
 Name="Temp"
 Title="WPF Temperature Converter"
 SizeToContent="WidthandHeight"&gt;
  &lt;DockPanel LastChildFill="False"&gt;
    &lt;Menu DockPanel.Dock="Top"&gt;
        &lt;MenuItem Header="_Scale"&gt;
            &lt;MenuItem Name="mnuFahrenheit" Header="_Fahrenheit"
             IsCheckable="True" IsChecked="True"/&gt;
            &lt;MenuItem Name="mnuCentigrade" Header="_Centigrade"
             IsCheckable="True"/&gt;
        &lt;/MenuItem&gt;
    &lt;/Menu&gt;
    &lt;Grid Width="230" Margin="40,10,10,10"&gt;
      &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
      &lt;/Grid.RowDefinitions&gt;
      &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto"/&gt;
        &lt;ColumnDefinition Width="80"/&gt;
        &lt;ColumnDefinition Width="60"/&gt;
      &lt;/Grid.ColumnDefinitions&gt;    
    &lt;Label Grid.Row="0" Grid.Column="0" Content="Fahrenheit"/&gt;
    &lt;Label Grid.Row="1" Grid.Column="0" Content="Centigrade"/&gt;
    &lt;TextBox Name="txtFahrenheit" Grid.Row="0" Grid.Column="1"
     Margin="5"/&gt;
    &lt;TextBox Name="txtCentigrade" Grid.Row="1" Grid.Column="1"
     Margin="5"/&gt;
    &lt;Button Name="btnF2C" Grid.Row="0" Grid.Column="2"
     Content="F&gt;C" Margin="5"/&gt;
    &lt;Button Name="btnC2F" Grid.Row="1" Grid.Column="2"
     Content="C&gt;F" Margin="5"/&gt;
    &lt;Button Name="btnQuit" Grid.Row="2" Grid.Column="1"
     Content="Quit" Margin="5"/&gt;
    &lt;/Grid&gt;
    &lt;ScrollBar Name="scrTemp" DockPanel.Dock="Right"  Width="20"
     Orientation="Vertical" Minimum="1" Maximum="213"&gt;
    &lt;/ScrollBar&gt;
  &lt;/DockPanel&gt;
&lt;/Window&gt;
</pre><p><img src="../images/wpf-example1.png" /></p><p>The window defined by this XAML is illustrated in the screen image shown above. Let us examine the XAML, component by component.</p><h4>Parent and Child Controls</h4><p>First, notice how the structure of the GUI is defined by enclosing the child components inside the opening and closing tags of its parent. So:</p><pre class="Code">&lt;Window
...
  &lt;DockPanel&gt;
...
  &lt;/DockPanel&gt;
&lt;/Window&gt;
</pre><p>specifies a Window control that <span class="Italic">contains</span> a DockPanel control.</p><p>Similarly, </p><pre class="Code">    &lt;Menu&gt;
        &lt;MenuItem ... &gt;
            &lt;MenuItem ... /&gt;
            &lt;MenuItem ... /&gt;
        &lt;/MenuItem&gt;
    &lt;/Menu&gt;
</pre><p>defines a Menu that contains a <span class="NetType">MenuItem</span>, that itself contains two other <span class="NetType">MenuItem</span> objects.</p><h4>Named and Un-named Controls</h4><p>Secondly, notice that certain objects are <span class="Italic">named</span> whereas others are not. For example: <span class="Code">TextBox Name="mnuFahrenheit</span> defines  a <span class="NetType">TextBox</span> named<span class="Name">txtFahenheit</span>; whereas <span class="Code">&lt;Dockpanel ...&gt;</span> defines an unnamed <span class="NetType">DockPanel</span> object.</p><p>Objects are given names so that they can be referenced from the code that displays content in the user-interface or handles the user actions. In this case, the code will read the content of the <span class="Name">txtFahrenheit</span><span class="NetType">TextBox</span> but has no need to reference the <span class="NetType">DockPanel</span>.</p><h4>The Main Window</h4><pre class="Code">&lt;Window
 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
 Name="Temp"
 Title="WPF Temperature Converter"
 SizeToContent="WidthandHeight"&gt;
...
&lt;/Window&gt;</pre><p>This extract of XAML defines a Window control; a top-level window that is equivalent to a Dyalog APL GUI Form.</p><p>The <span class="Name">xmlns</span> attributes define the XML namespaces (effectively the vocabulary of the xml scheme) and are mandatory in an XAML document.</p><p>The name of the <span class="NetType">TextBox</span> is <span class="Name">Temp</span>, and its caption is <span class="Name">WFP Temperature Converter</span>. The <span class="Member">SizeToContent</span> property is set to "WidthandHeight" , which causes the <span class="NetType">TextBox</span> to automatically size itself to fit its content in both horizontal and vertical directions. </p><h4>The DockPanel</h4><pre class="Code"> &lt;DockPanel LastChildFill="False"&gt;<br />..<br /> &lt;/DockPanel&gt;</pre><p>WPF provides a number of <span class="Italic">layout controls</span>. These are containers whose only purpose is to arrange child controls in a particular way, and to dictate how they are re-arranged when the parent window is resized. The <span class="NetType">DockPanel</span> is one of the simplest of the WPF layout controls.</p><p>In this case, the <span class="NetType">DockPanel</span> is controlling 3 child windows a Menu, a <span class="NetType">Grid</span> and a <span class="NetType">ScrollBar</span>.</p><p>The attachment of a particular child control is specified by setting its <span class="Member">DockPanel.Dock</span> property. By default, the last control added to a <span class="NetType">DockPanel</span> is stretched to fill the remaining space when the window is expanded. In this case, the requirement is for a fixed-width scrollbar attached to the right edge, so the default is overriden by setting the <span class="Member">LastChildFill</span> property to "False".</p><h4>The Menu</h4><pre class="Code">    &lt;Menu DockPanel.Dock="Top"&gt;
        &lt;MenuItem Header="_Scale"&gt;
            &lt;MenuItem Name="mnuFahrenheit" Header="_Fahrenheit"
             IsCheckable="True" IsChecked="True"/&gt;
            &lt;MenuItem Name="mnuCentigrade" Header="_Centigrade"
             IsCheckable="True"/&gt;
        &lt;/MenuItem&gt;
    &lt;/Menu&gt;</pre><p><img src="../images/wpf-example2.png" /></p><p>The above extract from the XAML defines a <span class="NetType">Menu</span>. Setting <span class="Member">Dock</span> to "Top" causes the <span class="NetType">Menu</span> as a whole to be docked, so that it appears like a menubar, along the top of the <span class="NetType">DockPanel</span>. The <span class="NetType">Menu</span> contains a single <span class="NetType">MenuItem</span> labelled <span class="Name">Scale</span> which itself contains two sub-items labelled <span class="Name">Fahrenheit</span> and <span class="Name">Centigrade</span> respectively. The <span class="Member">IsCheckable</span> property specifies whether or not the user can check the <span class="NetType">MenuItem</span>, and the <span class="Member">IsChecked</span> property sets and reports its checked state. The underscore characters (e.g. as in "_Scale") identify the following character as a keyboard shortcut.</p><h4>The Grid</h4><pre class="Code">    &lt;Grid Width="230" Margin="40,10,10,10"&gt;
    ...
    &lt;/Grid&gt;</pre><p>The <span class="NetType">Grid</span> object is another WPF layout control that organises other controls in rows and columns. Here, the XAML defines a <span class="NetType">Grid</span> with a width of 230; a left margin if 40, and a top, right and bottom margin of 10. As there is no explicit unit specified, the system uses the default device-independent unit ( <span class="Name">px</span>) of 1/96<sup>th</sup> inch.</p><p>The rows  and columns of a <span class="NetType">Grid</span> are defined by collections of <span class="NetType">RowDefinition</span> and <span class="NetType">ColumnDefinition</span> objects. </p><p>Here the XAML specifies that the <span class="NetType">Grid</span> contains 3 rows, each of which has a <span class="Member">Height</span> set to "Auto" which means that its height depends upon the height of its content.</p><pre class="Code">      &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
        &lt;RowDefinition Height="Auto"/&gt;
      &lt;/Grid.RowDefinitions&gt; </pre><p>Similarly, there are 3 columns. The first column (which will contain labels) takes its width from its content, i.e. it will be just wide enough to display the longest label. The other columns   for the edit boxes and buttons are specified to be 80px and 60px wide respectively. In this case, the content (<span class="NetType">TextBox</span> and <span class="NetType">Button</span> objects) will take their widths from that of the column.</p><pre class="Code">     &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width="Auto"/&gt;
        &lt;ColumnDefinition Width="80"/&gt;
        &lt;ColumnDefinition Width="60"/&gt;
      &lt;/Grid.ColumnDefinitions&gt; </pre><h4>The Label Objects(Column 1)</h4><pre class="Code">    &lt;Label Grid.Row="0" Grid.Column="0" Content="Fahrenheit"/&gt;
    &lt;Label Grid.Row="1" Grid.Column="0" Content="Centigrade"/&gt;</pre><p>Here the XAML specifies <span class="NetType">Label</span> objects Fahrenheit and Centigrade. Because they are defined within the<span class="Code"> &lt;Grid&gt; ...&lt;/Grid&gt;</span> tags, they are child objects of the Grid. In addition it is necessary to specify in which cells they are displayed using their <span class="Member">Grid.Row</span> and <span class="Member">Grid.Column</span> properties. Note that the cell coordinates have zero origin.</p><h4>The TextBox Objects(Column 2)</h4><pre class="Code">    &lt;TextBox Name="txtFahrenheit" Grid.Row="0" Grid.Column="1"
     Margin="5"/&gt;
    &lt;TextBox Name="txtCentigrade" Grid.Row="1" Grid.Column="1"
     Margin="5"/&gt;</pre><p>The XAML specifies two <span class="NetType">TextBox</span> objects named <span class="Name">txtFahrenheit</span> and<span class="Name"> txtCentigrade</span> respectively. Setting <span class="Member">Margin</span> to "5" means that a margin of 5px is applied around each edge; otherwise the text boxes would occupy the entire width of the column (80px). The effective width of each <span class="NetType">TextBox</span> will therefore be 70px <tt>(80-2×5)</tt>. </p><h4>The <span class="NetType">Button</span> Objects (Column 3)</h4><pre class="Code">    &lt;Button Name="btnF2C" Grid.Row="0" Grid.Column="2"
     Content="F&gt;C" Margin="5"/&gt;
    &lt;Button Name="btnC2F" Grid.Row="1" Grid.Column="2"
     Content="C&gt;F" Margin="5"/&gt;
    &lt;Button Name="btnQuit" Grid.Row="2" Grid.Column="1"
     Content="Quit" Margin="5"/&gt;
</pre><p>The XAML specifies three named <span class="NetType">Button</span> controls. Note that the caption on a <span class="NetType">Button</span> is specified by its <span class="Member">Content</span> property.</p><h4>The ScrollBar Object</h4><p>This example uses a <span class="NetType">ScrollBar</span> which the user may scroll to input a value, either in Fahrenheit or Centigrade depending upon which of the two menu items (<span class="Name">Fahrenheit</span> or <span class="Name">Centigrade</span>) is checked.<span class="MCTextPopup"><span class="MCTextPopupBody_0" style="display: none; ">A ScrollBar is not the ideal choice of control for this type of user-interation, but this example is designed to look and behave like the original Dyalog GUI example, which was writtenfor the original version of Dyalog APL for Windows .
</span><a href="javascript:void(0);" class="MCTextPopupSpot_0" onclick="FMCTextPopup( event, this ); return false;" style="font-size: 0.9em; vertical-align: super">1</a></span></p><pre class="Code">    &lt;ScrollBar Name="scrTemp" DockPanel.Dock="Right"  Width="20"
     Orientation="Vertical" Minimum="1" Maximum="213"&gt;
    &lt;/ScrollBar&gt;</pre><p>This XAML snippet defines a <span class="NetType">ScrollBar</span> named <span class="Name">scrTemp</span>.</p><p>Setting <span class="Member">DockPanel.Dock</span> to "Right" means that it will be docked (aligned) on the right edge of the <span class="NetType">DockPanel</span>. It will be a vertical scrollbar, have a fixed width of 20px and a default height. The range of the <span class="NetType">ScrollBar</span> is defined by its <span class="Member">Minimum</span> and <span class="Member">Maximum</span> properties which are set so that the <span class="NetType">ScrollBar</span> will specify a value in Fahrenheit.</p><p>Note that in order to cause the <span class="NetType">ScrollBar</span> to be docked (aligned) along the right edge of the <span class="NetType">DockPanel</span> it is necessary to set <span class="Member">LastChildFill</span> to "False" (for the <span class="NetType">DockPanel</span>) and <span class="Member">Dock</span> to "Right" (for the <span class="NetType">ScrollBar</span>), because the value of <span class="Member">LastChildFill</span> (default "True") overrides the <span class="Member">Dock</span> value of the last defined child of the <span class="NetType">DockPanel</span>.</p><h4>Note</h4><p>The XAML that defines this user-interface is at the same time both simple and complex. It is simple because (in this case) it is readily understood., It is complex because in order to write it, the user-interface designer must understand precisely how the  various controls and their properties behave and work together. For these details, you should refer to the appropriate documentation and check out the large number of examples published on the internet.</p><h4>The Code to display the XAML</h4><p>The function <tt>TempConverter</tt> shown below contains the code needed to display and operate the user interface whose layout is defined by the XAML described above.</p><pre>     ∇ TempConverter;str;xml;win;txtFahrenheit;txtCentigrade;mnuFahrenheit;mnuCentigrade;btnF2C;btnC2F;btnQuit;scrTemp;sink
[1]    ⎕USING←'System'
[2]    ⎕USING,←⊂'System.IO'
[3]    ⎕USING,←⊂'System.Windows.Markup'
[4]    ⎕USING,←⊂'System.Xml,system.xml.dll'
[5]    ⎕USING,←⊂'System.Windows.Controls.Primitives,WPF/PresentationFramework.dll'
[6]
[7]    str←⎕NEW StringReader(⊂XAML)
[8]    xml←⎕NEW XmlTextReader str
[9]    win←XamlReader.Load xml
[10]
[11]   txtFahrenheit←win.FindName⊂'txtFahrenheit'
[12]   txtCentigrade←win.FindName⊂'txtCentigrade'
[13]   mnuFahrenheit←win.FindName⊂'mnuFahrenheit'
[14]   mnuFahrenheit.onClick←'SET_F'
[15]   mnuCentigrade←win.FindName⊂'mnuCentigrade'
[16]   mnuCentigrade.onClick←'SET_C'
[17]   (btnF2C←win.FindName⊂'btnF2C').onClick←'f2c'
[18]   (btnC2F←win.FindName⊂'btnC2F').onClick←'c2f'
[19]   (btnQuit←win.FindName⊂'btnQuit').onClick←'Quit'
[20]   (scrTemp←win.FindName⊂'scrTemp').onScroll←'F2C'
[21]   sink←win.ShowDialog
     ∇
</pre><p>The variable <tt>XAML</tt> (a character vector) contains the XAML described previously.</p><p>Note that apart from the names given to the objects by the XAML and used by the function, the XAML and the code are independent.</p><p><tt>TempConverter[7-8]</tt> create an <span class="NetType">XamlReader</span> object from the character vector via <span class="NetType">StringReader</span> and <span class="NetType">XmlTextReader</span> objects.</p><pre>
[7]    str←⎕NEW StringReader(⊂XAML)
[8]    xml←⎕NEW XmlTextReader str</pre><p><tt>TempConverter[9]</tt> instantiates the XAML content  by calling its <span class="Member">Load</span> method, which returns a reference <tt>win</tt> to the top-level control (in this case a Window) defined therein. The Window is not yet visible.</p><pre>[9]    win←XamlReader.Load xml</pre><p>Earlier, it was explained that objects defined bt the XAML must be <span class="Italic">named</span> in order that they can be referenced (used) by the code. The mechanism to achieve this is to call the <span class="Member">FindName</span> method of the Window, which returns a reference to the specified (named) object. So these statements:</p><pre>
[11]   txtFahrenheit←win.FindName⊂'txtFahrenheit'
[12]   txtCentigrade←win.FindName⊂'txtCentigrade'</pre><p>obtain refs (in this case named <tt>txtFahrenheit</tt> and <tt>txtCentigrade</tt>) to  objects named <span class="Name">txtFahrenheit</span> and <span class="Name">txtCentigrade</span>. It is convenient (but not essential) to use the same name for the ref as is used for the control.</p><p>Most of the remaining statements obtain refs to the <span class="NetType">MenuItem</span>, <span class="NetType">Button</span> and <span class="NetType">ScrollBar</span> objects and attach callback functions to their <span class="Member">Click</span> and <span class="Member">Scroll</span> events respectively.</p><pre>[13]   mnuFahrenheit←win.FindName⊂'mnuFahrenheit'
[14]   mnuFahrenheit.onClick←'SET_F'
[15]   mnuCentigrade←win.FindName⊂'mnuCentigrade'
[16]   mnuCentigrade.onClick←'SET_C'
[17]   (btnF2C←win.FindName⊂'btnF2C').onClick←'f2c'
[18]   (btnC2F←win.FindName⊂'btnC2F').onClick←'c2f'
[19]   (btnQuit←win.FindName⊂'btnQuit').onClick←'Quit'
[20]   (scrTemp←win.FindName⊂'scrTemp').onScroll←'F2C'</pre><p>Finally the code displays the Window and hands it over to the user by calling the <span class="Member">ShowDialog</span> method of the top-level Window.</p><pre>
[21]   sink←win.ShowDialog</pre><p><span class="Member">ShowDialog</span> displays the Window <span class="Italic">modally</span>; i.e. until it is closed, the user may interact only with that Window. It is equivalent to <tt>⎕DQ win</tt> or <tt>win.Wait</tt> in the Dyalog built-in GUI.</p><h4>The CallBack Functions</h4><p>The callback functions are named as they are in the basic Dyalog GUI example and are remarkably similar. See <span class="XRef">Interface Guide: </span><span class="XRef">GUI Tutorial</span>.</p><p>Callback function <tt>f2c</tt> which is attached to the <span class="Member">Click</span> event of the <tt>btnF2C </tt>button (labelled <span class="Name">F&gt;C</span>) reads the character string in the <tt>txtFahrenheit</tt><span class="NetType">TextBox</span>, converts it to a number using <tt>Text2Num</tt>, calculates the equivalent in centigrade and then displays the result in the<tt> txtCentigrade</tt><span class="NetType">TextBox</span>.</p><p class="pagebreakafter"> </p><pre>     ∇ f2c;value
[1]    ⍝ Callback to convert Fahrenheit to Centigrade
[2]    :If 1=⍴,value←Text2Num txtFahrenheit.Text
[3]        txtCentigrade.Text←2⍕(value-32)×5÷9
[4]    :Else
[5]        txtCentigrade.Text←'invalid'
[6]    :EndIf
     ∇
</pre><p>For completeness, the <tt>Text2Num</tt> function is shown below. Note that if the user enters an invalid number, <tt>Text2Num</tt> returns an an empty vector, and the callback displays the text <span class="Name">invalid</span> instead.</p><pre>     ∇ num←Text2Num txt;val
[1]    val num←⎕VFI txt
[2]    num←val/num
     ∇
</pre><p>The <tt>c2f</tt> function converts from Centigrade to Fahrenheit when the user presses the button labelled <span class="Name">C&gt;F</span>.</p><pre>     ∇ c2f;value
[1]   ⍝ Callback to convert Centigrade to Fahrenheit
[2]    :If 1=⍴,value←Text2Num txtCentigrade.Text
[3]        txtFahrenheit.Text←2⍕32+value÷5÷9
[4]    :Else
[5]        txtFahrenheit.Text←'invalid'
[6]    :EndIf
     ∇
</pre><p>The callbacks <tt>F2C</tt> and <tt>C2F</tt>, one of which at a time is attached to the<span class="Member"> Scroll</span> event of the <span class="NetType">ScrollBar</span> object are shown below. The argument <tt>Msg</tt> contains two items, namely:</p><table style="width: 100%;" class="Event"><tr><td><tt>[1]</tt></td><td>Object</td><td>a ref to the ScrollBar object</td></tr><tr><td><tt>[2]</tt></td><td>Object</td><td>a ref to an object of type System.Windows.Controls.Primitives.ScrollEventArgs </td></tr></table><p>In this case the code uses the <span class="Member">NewValue</span> property of the ScrollEventArgs object. An alternative would be to refer to the<span class="Member"> Value</span> property of the <span class="NetType">ScrollBar</span> object </p><pre>
     ∇ F2C Msg;C;F;val
[1]   ⍝ Callback for Fahrenheit input via scrollbar
[2]    txtFahrenheit.Text←2⍕val←213-(2⊃Msg).NewValue
[3]    txtCentigrade.Text←2⍕(val-32)×5÷9
     ∇
</pre><p class="pagebreakafter"> </p><pre>
     ∇ C2F Msg;C;F;val
[1]   ⍝ Callback for Centigrade input via scrollbar
[2]    txtCentigrade.Text←2⍕val←101-(2⊃Msg).NewValue
[3]    txtFahrenheit.Text←2⍕32+val÷5÷9
     ∇
</pre><p>The callbacks <tt>SET_F </tt>and <tt>SET_C</tt> which are attached to the <span class="Member">Click</span> events of the two <span class="NetType">MenuItem</span> objects are shown below.</p><pre>     ∇ SET_F
[1]   ⍝ Sets the scrollbar to work in Fahrenheit
[2]    scrTemp.(Minimum Maximum)←1 213
[3]    scrTemp.onScroll←'F2C'
[4]    mnuFahrenheit.IsChecked←1
[5]    mnuCentigrade.IsChecked←0
     ∇


     ∇ SET_C
[1]   ⍝ Sets the scrollbar to work in Centigrade
[2]    scrTemp.(Minimum Maximum)←1 101
[3]    scrTemp.onScroll←'C2F'
[4]    mnuCentigrade.IsChecked←1
[5]    mnuFahrenheit.IsChecked←0
     ∇
</pre><p>Finally, the callback function<tt> Quit</tt> which is attached to the <span class="Member">Click</span> event on the <span class="Name">Quit</span> button, simply calls the <span class="Member">Close</span> method of the Window:</p><pre>     ∇ Quit arg
[1]    win.Close
     ∇
</pre><p>Notice that unlike its equivalent in the Dyalog GUI, it is not appropriate to close the Window using the expression <tt>⎕EX 'win'</tt>. This would expunge the ref to the Window but have no effect on the Window itself.</p><script src="../../../help.js"></script></body>
</html>