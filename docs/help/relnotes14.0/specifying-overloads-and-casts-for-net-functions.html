<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../help.css"></head>
<body><h2>Specifying Overloads and Casts for .Net</h2><h4>Specifying Overloads and Casts</h4><p>If a .Net function is overloaded in terms of the types of arguments it accepts, Dyalog APL chooses which overload to call depending upon the data types of the arguments passed to it. For example, if a .Net function <span class="Code">foo()</span> is declared to take a single argument either of type <span class="Code">int</span> or of type <span class="Code">double</span> APL would call the first version if you called it with an integer value and the second version if you called it with a non-integer value. </p><p>In some circumstances it may be desirable to override this mechanism and explicitly specify which overload to use.</p><p>A second requirement is to be able to specify to what .Net types APL should coerce arrays before calling a .Net function. For example, if a parameter to a .Net function is declared as type <span class="Code">System.Object</span>, it might be necessary to force the APL argument to be cast to a particular  <span class="Italic">type</span> of <span class="Code">Object</span> before the function is called.</p><p>Both these requirements are met by calling the function via the Variant operator <tt>⍠</tt>. There are two options, <span class="Parameter">OverloadTypes</span> (the Principle Option) and <span class="Parameter">CastToTypes</span>. Each option takes an array of refs to Net types, the same length as the number of parameters to the function.</p><h4>OverloadTypes Examples</h4><p>To force APL to call the double version of function <span class="Code">foo()</span> regardless of the type of the argument <tt>val</tt>:</p><pre>      (foo ⍠('OverloadTypes'Double))val</pre><p>or more simply:</p><pre>      (foo ⍠Double)val</pre><p>Note that <tt>Double</tt> is a ref to the .Net type <span class="Code">System.Double</span>.</p><pre>      ⎕USING←'System'
      Double
(System.Double)
</pre><p>Taking this a stage further, suppose that <span class="Code">foo()</span> is defined with 5 overloads as follows:</p><pre class="Code">foo()<br />foo(int i)<br />foo(double d)<br />foo(double d, int i)<br />foo(double[] d)<br /></pre><p>The following statements will call the niladic, double, (double, int) and double[] overloads respectively.</p><p class="pagebreakafter"><br /></p><pre>(foo ⍠ (⊂⍬)) ⍬                               ⍝ niladic
(foo ⍠ Double) 1                             ⍝ double
(foo ⍠(⊂Double Int32))1 1                   ⍝ double,int
(foo ⍠(Type.GetType ⊂'System.Double[]'))⊂1 1 ⍝ double[]</pre><p>Note that in the niladic case, an enclosed empty vector is used to represent a null reference to a .Net type.</p><h4>CastToTypes Example</h4><p>The .Net function <span class="Code">Array.SetValue()</span> sets the value of a specified element (or elements) of an array. The first argument, the new value, is declared as <span class="Code">System.Object</span>, but the value supplied must correspond to the type of the <span class="Code">Array</span> in question. APL has no means to know what this is and will therefore pass the value <span class="Italic">as is</span>, i.e. in whatever internal format it happens to be at the time. For example:</p><pre>      ⎕USING←'System'

      ⍝ create a Boolean  array with 2 elements
      BA←Array.CreateInstance Boolean 2
      BA.GetValue 0 ⍝ get the 0th element
0</pre><pre>      ⍝ attempt to set the 0th element to 1 (AKA true)</pre><pre>
      BA.SetValue 1 0
EXCEPTION: Cannot widen from source type to target type
either because the source type is a not a primitive type or the conversion cannot be accomplished.
test[5] BA.SetValue 1 0
       ∧ </pre><p>The above expression failed because APL passed the first argument 1 ,unchanged from its current internal representation, as a 1-byte integer which does not fit into a Boolean element.</p><p>To rectify the situation, APL must be told to cast the argument to a Boolean as follows:</p><pre>      (BA.SetValue ⍠ ('CastToTypes'(Boolean Int32)))1 0
      BA.GetValue 0 ⍝ get the 0th element
1</pre><h4 class="ExampleNewPage">Overloaded Constructors</h4><p>If a class provides constructor overloads, a similar mechanism is used to specify which of the constructors is to be used when an instance of the class is created using <tt>⎕NEW</tt>.</p><p>For example, if <span class="Code">MyClass</span> is a .Net class with an overloaded constructor, and one of its constructors is defined to take two parameters; a <span class="Code">double</span> and an <span class="Code">int</span>, the following statement would create an instance of the class by calling that specific constructor overload:</p><pre>      (⎕NEW ⍠ (⊂Double Int32)) MyClass (1 1)</pre><script src="../../help.js"></script></body>
</html>