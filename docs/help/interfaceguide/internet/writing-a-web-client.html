<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><a name="_Toc289343978"></a>Writing a Web Client</h2><p>A sample Web client is provided in the <tt>BROWSER</tt> namespace in the workspace <span class="Code">samples\tcpip\www.dws</span>.</p><p>Before you can use <tt>BROWSER.QUERY</tt> you must be connected to the Internet. See <span class="Italic">APL and the Internet</span> for details.</p><p>The main function is <tt>BROWSER.QUERY</tt>. This function is intended to be used in one of two ways:</p><h4>Using a Proxy Server</h4><p>If you are connected to the Internet through a secure proxy server or<span class="Italic"> firewall</span> (as is common in many commercial organisations), you may <b>only</b> connect to your firewall; you cannot connect directly to any other server. Effectively, the <b>only external</b> IP address to which you may connect a TCPSocket as a client is the IP address of your firewall.</p><p>In this case, you should set the values of the variables <tt>BROWSER.IP_ADDRESS</tt> and <tt>BROWSER.PORT_NUMBER</tt> to the IP address and port number of your firewall.</p><p>The right argument to <tt>BROWSER.QUERY</tt> is a character string that includes the name of the web site or server as part of the query. For example, the following statement will retrieve the Microsoft home page:</p><pre>      BROWSER.QUERY'GET http://www.microsoft.com/'</pre><h4>Using a Direct Connection</h4><p>If you are directly connected to the Internet or you use dial-up networking to connect to an Internet provider, you may create TCPSocket objects that are directly connected to any server on the Internet.</p><p>In this case, the <span class="Italic">left</span> argument to the function is the address and port number of the server to which you wish to connect (the port number is optional and defaults to 80). The <span class="Italic">right</span> argument is the command that you wish the server to execute. Furthermore, the address may be expressed as the <span class="Italic">IP address</span> of the server or as the <span class="Italic">name</span> of the server.</p><p>For example, to obtain the Microsoft home page :</p><pre>      '207.46.192.254'BROWSER.QUERY'GET /'
or
      'www.microsoft.com'BROWSER.QUERY'GET /'</pre><p>The result of the query is not returned by the <tt>BROWSER.QUERY</tt> function, but is instead obtained from the server <span class="Italic">asynchronously</span> by callback functions and then deposited in the variable <tt>BROWSER.HTML</tt>. In this example, the call-backs report the progress of the transaction as shown below. This approach is perhaps unusual in APL, but it perfectly illustrates the event-driven nature of the process.</p><h4>Using a Firewall</h4><pre>      BROWSER.QUERY 'GET http://www.microsoft.com'
Connected to 193.32.236.22
... Done
Received 39726 Bytes
Response is in:
#.BROWSER.HTML</pre><h4>Using a Direct Connection</h4><pre>      'www.microsoft.com' BROWSER.QUERY 'GET /'
www.microsoft.com resolved to IP Address 207.46.192.254
Connected to 207.46.192.254
... Done
Received 39726 Bytes
Response is in:
#.BROWSER.HTML</pre><p class="aftercode_3">There are two points to note. In the first case (using a firewall) the IP address reported is the IP address of your firewall. In the second case, there is an additional first step involved as the name of the server is resolved to its IP address (note too that this web site provides a number of IP addresses).</p><p>To keep the examples simple, <tt>BROWSER.QUERY</tt> has been written to handle only a single query at a time. Strictly speaking, it could initiate a second or third query before the result of the first had been received. This would merely entail creating multiple sockets instead of a single one.</p><p>The various functions in the <tt>BROWSER</tt> namespace are as follows:</p><table><tr><td><tt>QUERY</tt></td><td>User function to initiate a Web query</td></tr><tr><td><tt>GOTADDR</tt></td><td>callback: reports name resolution (server name to IP address)</td></tr><tr><td><tt>CONNECT </tt></td><td>callback: handles the connection to the server</td></tr><tr><td><tt>RECEIVE</tt></td><td>callback: collects the data packets as they arrive from the server</td></tr><tr><td><tt>CLOSE</tt></td><td>callback: stores the result of the query and expunges TCPSocket</td></tr><tr><td><tt>ERROR</tt></td><td>callback: handles errors</td></tr></table><h4><a name="_Toc289343979"></a>The QUERY function</h4><pre class="APLCodeSmall">     ∇ {LARG}QUERY QRY;IP;PN;CALLBACKS;NS;P;SERVER
[1]   ⍝ Perform world wide web query
[2]    :If 0=⎕NC'LARG'
[3]        IP←IP_ADDRESS
[4]        PN←PORT_NUMBER
[5]        QRY,←' HTTP/1.0',⎕AV[4 3 4 3]
[6]    :Else
[7]        :If (¯2≡≡LARG)^(,2)≡⍴LARG
[8]            IP PN←LARG
[9]        :Else
[10]           IP PN←LARG 80
[11]       :EndIf
[12]       QRY,←' HTTP/1.1',⎕AV[4 3],'Host:',IP,4⍴⎕AV[4 3]
[13]   :EndIf
[14]
[15]  ⍝ Server specified by name or IP address ?
[16]   :If ^/IP∊'. ',⎕D
[17]       SERVER←('RemoteAddr'IP)
[18]   :Else
[19]       SERVER←('RemoteAddrName'IP)
[20]   :EndIf
[21]
[22]   NS←(''⎕NS''),'.'
[23]   CALLBACKS←⊂('TCPGotAddr'(NS,'GOTADDR'))
[24]   CALLBACKS,←⊂('TCPConnect'(NS,'CONNECT'))
[25]   CALLBACKS,←⊂('TCPRecv'(NS,'RECEIVE'))
[26]   CALLBACKS,←⊂('TCPClose'(NS,'CLOSE'))
[27]   CALLBACKS,←⊂('TCPError'(NS,'ERROR'))
[28]
[29]  ⍝ Expunge TCPSocket in case of previous error
[30]   ⎕EX'S0'
[31]
[32]  ⍝ Make new S0 namespace containing QRY
[33]   'S0'⎕NS'QRY'
[34]  ⍝ Then make S0 a TCPSocket object
[35]   P←SERVER('RemotePort'PN)('Event'CALLBACKS)
[36]   S0.⎕WC(⊂'TCPSocket'),P ⋄ ⎕DQ'S0'
     ∇</pre><p>The first 13 lines of the function process the optional left argument and are largely unremarkable.</p><p>However, note that if you are using a firewall or proxy (no left argument), <tt>QUERY[5]</tt> adds a header to request HTTP/1.0 protocol. If you are using a direct connection, <tt>QUERY[12]</tt> instead adds a request for HTTP/1.1 protocol and a <span class="Italic">Host</span> header (which in this case it knows). A Host header is mandatory for HTTP/1.1 and your firewall may add one for you.</p><p><tt>QUERY[16-20]</tt>sets the variable <tt>SERVER</tt> to specify either RemoteAddr or RemoteAddrName according to whether the user specified the IP address or the name of the server.</p><p><tt>QUERY[22-27]</tt>set up a variable <tt>CALLBACKS</tt> which associates various functions with various events. Full path-names are used for the callback functions because they will be associated by a <tt>⎕WC</tt> statement that is executed <span class="Italic">within</span> the <tt>S0</tt> namespace.</p><p><tt>QUERY[30]</tt>expunges the object <tt>S0</tt>.  This is done only in case an error occurred previously and the object has been left around.</p><p><tt>QUERY[33]</tt>makes a new namespace called <tt>S0</tt> and copies the variable <tt>QRY</tt> into it. This is done because the query cannot be submitted to the server until after a connection has been made. Thus the query is encapsulated within the TCPSocket object to make it available to the callback function <tt>CONNECT</tt> that will handle this event. A less elegant solution would be to use a global variable.</p><p><tt>QUERY[36]</tt>creates a new client TCPSocket object associated with the namespace <tt>S0</tt>.</p><p>A more obvious solution would be..</p><pre>[33]   'S0' ⎕WC(⊂'TCPSocket'),P
[34]   S0.QRY←QRY</pre><p>However, this is inadvisable because TCP events can occur as soon as the object has been created. If the TCPConnect event fired before <tt>QUERY[34]</tt> could be executed, the <tt>CONNECT</tt> callback function would fail with a <tt>VALUE ERROR</tt> because <tt>S0.QRY</tt> would not yet be defined. This is also a reason for attaching the callback functions in the <tt>⎕WC</tt> statement and not in a subsequent <tt>⎕WS</tt>. You do not want the TCPConnect event to fire when there is no callback attached.</p><p>Note that these timing issues are only relevant because <tt>BROWSER.QUERY</tt> is a user-called function and not a callback. If it were a callback, APL would automatically queue the incoming TCP events until it (the callback) had terminated.</p><p>Depending upon how the function was called, the next part of the process is handled by the <tt>GOTADDR</tt> or the <tt>CONNECT</tt> callback.</p><h4><a name="_Toc289343980"></a>The GOTADDR callback function</h4><pre>     ∇ GOTADDR MSG;NAME;IP
[1]    NAME IP←(⊃MSG)⎕WG'RemoteAddrName' 'RemoteAddr'
[2]    NAME,' resolved to IP Address ',IP
     ∇</pre><p>The <tt>GOTADDR</tt> callback function is invoked when the TCPGotAddr event occurs. This happens if the RemoteAddrName was specified when the TCPSocket was created.</p><p>The function merely obtains the name and newly resolved IP address of the server from the RemoteAddrName and RemoteAddr properties of the TCPSocket object and reports them in the session.</p><h4><a name="_Toc289343981"></a>The CONNECT callback function</h4><pre>     ∇ CONNECT MSG
[1]    ⎕CS⊃MSG
[2]    'Connected to ',⎕WG'RemoteAddr'
[3]    BUFFER←''
[4]    2 ⎕NQ'' 'TCPSend' QRY
     ∇</pre><p>The <tt>CONNECT</tt> function is invoked when the TCPConnect event occurs. This happens when the server accepts the client.</p><p>Its argument <tt>MSG</tt> , supplied by APL, is a 2-element vector containing:</p><table><tr><td class="DyalogPlain">MSG[1]</td><td>The name of the TCPSocket object</td></tr><tr><td class="DyalogPlain">MSG[2]</td><td>The name of the event ('<tt>TCPConnect'</tt>)</td></tr></table><p class="aftercode_3"><tt>CONNECT[1]</tt>changes to the namespace of the TCPSocket object.</p><p><tt>CONNECT[2]</tt>displays the IP address of the server to which the client has successfully connected. This is obtained from the RemoteAddr property of the TCPSocket object.</p><p><tt>CONNECT[3]</tt>initialises a variable <tt>BUFFER</tt> which will be used to collect incoming data from the server. Notice that as the function has changed to the TCPSocket namespace, this variable is encapsulated within it rather than being global.</p><p><tt>CONNECT[3]</tt>uses the TCPSend method to send the query (the <tt>QRY</tt> variable was encapsulated within the TCPSocket object when it was created by the <tt>QUERY</tt> function) to the server. </p><p>The next part of the process is handled by the <tt>RECEIVE</tt> callback.</p><h4><a name="_Toc289343982"></a>The RECEIVE callback function</h4><pre>     ∇ RECEIVE M
[1]    ⎕CS⊃M
[2]    BUFFER,←3⊃M
[3]    :If ∨/'&lt;/html&gt;'⍷##.lcase 3⊃M
[4]        (⊃M)##.⎕WS'TargetState' 'Closed'
[5]    :EndIf
     ∇ </pre><p>The <tt>RECEIVE</tt> function is invoked when the TCPRecv event occurs. This happens whenever a packet of data is received. As the response from the server can be of arbitrary length, the job of the <tt>RECEIVE</tt> function is simply to collect each packet of data into the <tt>BUFFER</tt> variable.</p><p>Its argument <tt>MSG</tt> , supplied by APL, is a 3-element vector containing:</p><table><tr><td class="DyalogPlain">MSG[1]</td><td>The name of the TCPSocket object</td></tr><tr><td class="DyalogPlain">MSG[2]</td><td>The name of the event ('<tt>TCPRecv'</tt>)</td></tr><tr><td class="DyalogPlain">MSG[3]</td><td>The data</td></tr><tr><td class="DyalogPlain">MSG[4</td><td>IP address of the client</td></tr><tr><td class="DyalogPlain">MSG[5]</td><td>Port number of the client</td></tr></table><p><tt>RECEIVE[1]</tt>changes to the namespace of the TCPSocket object.</p><p><tt>RECEIVE[2]</tt>catenates the data onto the variable <tt>BUFFER</tt>, which is encapsulated within the TCPSocket object.</p><p><tt>RECEIVE[3]</tt>checks for the presence of an <span class="Italic">end-of document</span>  HTML tag, which indicates that the entire page has arrived, and if so</p><p><tt>RECEIVE[4]</tt>sets the TargetState property of the TCPSocket to <tt>'Closed'</tt>. This initiates the closure of the socket. Although a client can close a socket by expunging the associated TCPSocket namespace, our data (<tt>BUFFER</tt>) is in this namespace and we do not want to lose it.</p><p>Note that it is necessary for <tt>RECEIVE</tt> to detect the end-of-document in this way, so as to support HTTP/1.1 protocol.</p><h4><a name="_Toc289343983"></a>The CLOSE callback function</h4><pre>     ∇ CLOSE MSG
[1]    HTML←(⊃MSG)⍎'BUFFER'
[2]    ⎕EX⊃MSG
[3]    '... Done'
[4]    'Received ',(⍕⍴HTML),' Bytes'
[5]    'Response is in:'
[6]    (''⎕NS''),'.HTML'
     ∇</pre><p>The <tt>CLOSE</tt> function is invoked when the TCPClose event occurs. This happens when the server closes the socket. If the protocol is HTTP/1.0, this will be done immediately after the server has sent the data in response to the query. If the protocol is HTTP/1.1, the closure may be performed at the request of the client.</p><p>Note that the data has been buffered by the <tt>RECEIVE</tt> function as it arrived.</p><p>Its argument <tt>MSG</tt> , supplied by APL, is a 2-element vector containing:</p><table><tr><td class="DyalogPlain">MSG[1]</td><td>The name of the TCPSocket object</td></tr><tr><td class="DyalogPlain">MSG[2]</td><td>The name of the event ('<tt>TCPClose'</tt>)</td></tr></table><p><tt>CLOSE[1]</tt>copies the contents of the <tt>BUFFER</tt> variable (that is local to the TCPSocket object) into the <tt>HTML</tt> variable that is global within the current (<tt>BROWSER</tt>) namespace. (Clearly this design would be inadequate if <tt>BROWSER</tt> was extended to support multiple concurrent queries.)</p><p><tt>CLOSE[2]</tt>expunges the TCPSocket object</p><p><tt>CLOSE[3-6]</tt>reports a successful end to the query and displays the size of the result.</p><h4><a name="_Toc289343984"></a>The ERROR callback function</h4><pre>     ∇ R←ERROR MSG
[1]    DISPLAY MSG
[2]    ⎕EX⊃MSG
[3]    R←0
     ∇</pre><p>The <tt>ERROR</tt> function is invoked if and when a TCP/IP error occurs.</p><p>Its argument <tt>MSG</tt> , supplied by APL, is a 4-element vector containing:</p><table><tr><td class="DyalogPlain">MSG[1]</td><td>The name of the TCPSocket object</td></tr><tr><td class="DyalogPlain">MSG[2]</td><td>The name of the event ('<tt>TCPError'</tt>)</td></tr><tr><td class="DyalogPlain">MSG[3]</td><td>An error number</td></tr><tr><td class="DyalogPlain">MSG[4</td><td>An error message</td></tr></table><p><tt>ERROR[1]</tt>displays the contents of <tt>MSG</tt> using the <tt>DISPLAY</tt> function.</p><p><tt>ERROR[2]</tt>expunges the TCPSocket object (it is no longer usable)</p><p><tt>ERROR[3]</tt>returns a 0. This tells APL <span class="Italic">not</span> to perform the normal default processing for this event, which is to display a message box.</p></body>
</html>