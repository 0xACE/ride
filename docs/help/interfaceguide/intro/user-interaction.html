<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><a name="User_Interaction"></a>User Interaction &amp; Events</h2><h4><a name="User_Control"></a>Giving Control to the User</h4><p>As we have seen, <tt>⎕WC</tt> and <tt>⎕WS</tt> are used to build up the definition of the user-interface as a hierarchy of <b>objects</b> with <b>properties</b>. Notice that the interface is defined not only in terms of its appearance and general behaviour, but also by specification of the Event property, in terms of how it reacts to user actions.</p><p>Once you have defined your interface, you are ready to give control to the user. This is simply done by calling <tt>⎕DQ</tt>. Alternatively, you may use the Wait method (if appropriate) which is identical to <tt>⎕DQ</tt> in its operation.</p><p><tt>⎕DQ</tt> performs several tasks. Firstly, it displays all objects that have been created but not yet drawn. When you create objects, Dyalog APL/W automatically buffers the output so as to avoid unpleasant flashing on the screen. Output is flushed when APL requires input (at the 6-space prompt) and by <tt>⎕DQ</tt>. Thus if you write a function that creates a Form containing a set of controls, nothing is drawn until, later on in the function, you call <tt>⎕DQ</tt>. At this point the Form and its contents are displayed in a single screen update, which is visually more pleasing than if they were drawn one by one. A second task for <tt>⎕DQ</tt> is to cause the system to wait for user events. Objects that you create are immediately active and capable of generating events. During development and testing, you can immediately use them without an explicit <span class="Italic">wait</span>. However, unless your application uses the <b>Session </b>in conjunction with GUI objects you must call <tt>⎕DQ</tt> to cause the application to wait for user input. In a run-time application, <tt>⎕DQ</tt> is <b>essential</b>.</p><p>The right argument to <tt>⎕DQ</tt> specifies the objects with which the user may interact. If it specifies <tt>'.'</tt>, the user may interact with <b>all</b> active objects owned by the current thread <b>and</b> with any new objects which are created in callback functions. If not, the right argument is a simple character vector or a vector of character vectors, containing the names of one or more Form or PropertySheet objects and the Clipboard object, or the name of a single <span class="span_11">modal</span> object of type FileBox, Locator, MsgBox or Menu. All specified objects must be owned by the current thread.</p><p>In general, <tt>⎕DQ</tt> first updates the screen with any pending changes, then hands control to the user and waits for an event. If its right argument is <tt>'.' </tt><tt>⎕DQ</tt> processes events for all active objects, i.e. for those objects and their children whose Active property is 1. If the right argument contains the name of one or more Form and/or Clipboard objects, <tt>⎕DQ</tt> processes events for all of these objects and their children, and (if the current thread is thread 0) for the Root object, but ignores any others, even though they may be currently active.</p><p>If the right argument specifies a single modal object, <tt>⎕DQ</tt> displays the object on the screen, handles user-interaction with it, and then hides the object when the user has finished with it. An event is generated according to the manner in which the user terminated.</p><p>Events are managed by both the Operating System and by <tt>⎕DQ</tt> using a <b>queue</b>. A detailed understanding of how the queue works is not absolutely necessary, and you may skip the following explanation. However, if you are planning to develop major applications using the GUI, please continue.</p><h4><a name="Event_Queue"></a>The Event Queue</h4><p>There are in fact two separate queues, one maintained by MS-Windows and one internal to APL. The MS-Windows queue is used to capture all events that APL needs to process. These include events for your GUI objects as well as other events concerned with APL's own Session Window, Edit Windows, etc. At various points during execution, APL reads events from the MS-Windows queue and either processes them immediately or, if they are events concerned with objects you have defined with <tt>⎕WC</tt>, APL places them on its own internal queue. It is this queue to which <tt>⎕DQ</tt> looks for its next event.</p><p>When <tt>⎕DQ</tt> receives an event, it can either ignore it, process it internally, execute a string, call a callback function, or terminate according to the action you have defined for that event. The way you define different actions is described in detail later in this Chapter.</p><p>If you have disabled a particular event by setting its action code to <tt>¯1</tt>, <tt>⎕DQ</tt> simply ignores it. For example, if you set the action code of a KeyPress event to <tt>¯</tt>1, keystrokes in that object will be ignored. If you have told <tt>⎕DQ</tt> to process an event normally (the default action code of 0) <tt>⎕DQ</tt> performs the default processing for the event in question. For example, the default processing for a KeyPress event in an Edit object is to display the character and move the input cursor.</p><p>If you have associated a string or a callback function with a particular event in a particular object, <tt>⎕DQ</tt> executes the string or invokes the callback function for you. During the execution of the string or the callback function, the user may cause other events. If so, these are added to APL's internal queue but they are not acted upon immediately. When the execution of the string or the callback function terminates, control returns to <tt>⎕DQ</tt> which once more looks to the internal queue. If another event has been added while the callback function was running, this is read and acted upon. If not, <tt>⎕DQ</tt> looks to the MS-Windows queue and waits for the next event to occur.</p><p>If you have associated an <b>asynchronous</b> callback function with an event (by appending the character "&amp;" to the name of the function), <tt>⎕DQ</tt> starts the callback function in a new thread and is then immediately ready to process the next event; <tt>⎕DQ</tt> does not wait for an asynchronous callback function to complete. </p><p>If <tt>⎕DQ</tt> reads an event with an associated action code of 1<tt>,</tt> it terminates and returns the <b>event message</b> which was generated by the event, as a result. The normal processing for the event is not actioned. During the time between <tt>⎕DQ</tt> terminating and you calling it again, events are discarded. Events are only stored up in the queue if <tt>⎕DQ</tt> is active (i.e. there is a <tt>⎕DQ</tt> in the state indicator). It is therefore usually better to process events using callback functions.</p><h4><a name="Event_Property"></a>Assignment and reference to the Event Property</h4><p>There are a number of special considerations when using assignment and reference to the Event property.</p><p>You can set the action for a single event by prefixing the Event name by "on". For example, to set the action of a MouseUp event on a Form <tt>F</tt> to execute the callback function <tt>FOO</tt>:</p><pre>      F.onMouseUp←'UP'
      F.onMouseUp
 #.UP</pre><p>Notice that the value returned (<tt>#.UP</tt>) is not necessarily exactly the same as you set it (<tt>UP</tt>).</p><p>If you reference the Event property, you will obtain all the current settings, reported in order of their internal event number. Notice the use of distributed strand notation to set more than one event in the same statement.</p><pre>      F.(onMouseUp onMouseDown)←'UP' ('DOWN' 42)
      F.Event
  onMouseDown  #.DOWN  42   onMouseUp  #.UP  </pre><p>If you set the Event property using assignment, all the event actions are redefined, i.e. previous event settings are lost. For example:</p><pre>      F.(onMouseUp onMouseDown)←'UP' ('DOWN' 42)
      F.Event
  onMouseDown  #.DOWN  42   onMouseUp  #.UP  
 
      F.Event←'onMouseMove' 'MOVE'
      F.Event
  onMouseMove  #.MOVE  </pre><p>The All event can also be set by assignment, and it too clears previous settings. Notice too that a subsequent reference to a specific event using the "on" prefix, will report the "All" setting, unless it is specifically reset.</p><pre>      F.(onMouseUp onMouseDown)←'UP' ('DOWN' 42)
      F.Event
  onMouseDown  #.DOWN  42   onMouseUp  #.UP  
 
      F.onAll←'FOO'
      F.Event
  onAll  #.FOO  
 
      F.onMouseMove
 #.FOO
 
      F.Event←'onMouseMove' 'MOVE'
      F.Event
  onMouseMove  #.MOVE  
 </pre><p>If no events are set, the result obtained by <tt>⎕WG</tt> and the result obtained by referencing Event directly are different:</p><pre>      'F'⎕WC'Form'
      DISPLAY 'F'⎕WG'Event'
.→--.
|0 0|
'~--'
      DISPLAY F.Event
.⊖------------.
| .→--------. |
| | .⊖. .⊖. | |
| | | | | | | |
| | '-' '-' | |
| '∊--------' |</pre><p class="Dyalog_2">'∊------------'</p><h4><a name="Callback_Functions"></a>Callback Functions</h4><p>By setting the action code to 1 for all the events you are interested in, you could write the control loop in your application as:</p><pre>   Loop:  Event ← ⎕DQ 'system'
          test Event[1] (object name)
          and  Event[2] (event code)
          →Label</pre><pre>   Label: process event for object
          →Loop</pre><p>However, such code can be error prone and difficult to maintain. Another limitation is that events that occur between successive calls on <tt>⎕DQ</tt> are discarded.</p><p>An alternative is to use callback functions. Not only do they encourage an object-oriented modular approach to programming, but they can also be used to validate the user's actions and prevent something untoward happening. For example, a callback function can prevent the user from terminating the application at an inappropriate point. The use of callback functions will also produce applications that execute faster than those that process events by exiting <tt>⎕DQ</tt> and looping back again as above.</p><p>You associate a callback function with a particular event or set of events in a given object. There is nothing to prevent you from using the same callback function with several objects, but it only makes sense to do so if the processing for the event(s) is common to all of them. The object that caused the event is identified by the first element of the right argument when the callback is invoked.</p><p>When an event occurs that has an action set to a character vector, the system looks for a function with that name. If none exists <tt>⎕DQ</tt> terminates with a <tt>VALUE ERROR</tt>. If the function does exist, it is called. If the callback function was called <tt>FOO</tt> and it stopped on line [1], the State Indicator would be:</p><pre>      )SI
FOO[1]*
⎕DQ
...</pre><p>A callback function may be defined with any syntax, i.e. it may be dyadic, monadic, or niladic. If it is monadic or dyadic, <tt>⎕DQ</tt> calls it with the event message as its right argument. If the function is dyadic, its left argument will contain the value of the array that was associated with the event.</p><p>A callback function is otherwise no different from any other function that you can define. Indeed there is nothing to prevent you from calling one explicitly in your code. For example, a callback function that is invoked automatically could call a second callback function directly, perhaps to simulate another event.</p><p>By default, a callback function is run synchronously. This means that <tt>⎕DQ</tt> waits for it to return a result before attempting to process any other events. Events that are generated by Windows while the callback function is running are simply queued.</p><p>Alternatively, you may specify that a callback function is to be run <b>asynchronously</b>. In this case, <tt>⎕DQ</tt> starts the function in a new thread, but instead of waiting for it to complete, proceeds immediately to the next event in the queue. See Asynchronous Callbacks for further information.</p><h4 class="ExampleNewPage">Modifying or Inhibiting the Default Processing</h4><p>It is often desirable to inhibit the normal processing of an event, and it is occasionally useful to substitute some other action for the default. One way of inhibiting an event is to set its action code to <tt>¯1</tt>. However this mechanism is non-selective and is not always applicable. You can use it for example to ignore <b>all</b> keystrokes, but not to ignore particular ones.</p><p>Synchronous callback functions provide an additional mechanism which allows you to selectively inhibit default processing of an event. The mechanism also allows you to modify the event in order to achieve a different effect.</p><p>For example, you can use a callback function to ignore a <b>particular</b> keystroke or set of keystrokes, or even to replace the original keystroke with a different one. Similarly, you can use a callback function to selectively ignore a LostFocus event if the data in the field is invalid. Callback functions therefore give you much finer control over event processing. The mechanism uses the result returned by the callback function and operates as follows.</p><p>When an event occurs that has a synchronous callback function attached, <tt>⎕DQ</tt> invokes the callback function (passing it the event message as its right argument) before performing any other action and waits for the callback to complete. When the callback function terminates (exits) <tt>⎕DQ</tt> examines its result.</p><p>If the callback function returned no result, or returned a scalar 1 or the identical event message with which it was invoked, <tt>⎕DQ</tt> then carries out the default processing for the event in question. If the callback function returned a 0, <tt>⎕DQ</tt> takes no further action and the event is effectively ignored. Finally, if the callback returns a <b>different</b> event message (from the one supplied as its right argument), <tt>⎕DQ</tt> performs the default processing associated with the new event rather than with the original one.</p><p>For example, consider a callback function attached to a KeyPress event in an Edit object. When the user presses a key, for the sake of example, the unshifted "a" key, <tt>⎕DQ</tt> invokes the callback function, passing it the corresponding event message as its right argument. This event message includes information about which key was pressed, in this case "a". The various possibilities are:</p><ul><li value="1">If the callback function returns a value of 1 or the same event message with which it was invoked, <tt>⎕DQ</tt> carries out the default processing for the original event. In this case a lower-case "a" is displayed in the field.</li><li value="2">If the callback function returns a value of 0, <tt>⎕DQ</tt> takes no further action and the keystroke is ignored.</li><li value="3">If the callback function modifies the event message and changes the key from an "a" to a "b", <tt>⎕DQ</tt> carries out the default processing associated with the <span class="Italic">new</span> event, and displays a lower-case "b" instead.</li></ul><p>Note that asynchronous callback functions may not be used to modify or inhibit the default processing because their results are ignored.</p><h4><a name="NQ_Events"></a>Generating Events using <tt>⎕NQ</tt></h4><p>The <tt>⎕NQ</tt> system function is used to generate events under program control and has several uses.</p><p>Firstly, it can be used to do something automatically for the user. For example, the following expression gives the input focus to the object <tt>Form1.ED1.</tt></p><pre>        ⎕NQ Form1.ED1 'GotFocus'</pre><p>Secondly, <tt>⎕NQ</tt> can be used to generate user-defined events which trigger special actions either by invoking callback functions or by causing <tt>⎕DQ</tt> to terminate. For example, if you were to define the Event property on <tt>'Form1'</tt> as:</p><pre>      'Form1' ⎕WS ('Event' 1001 'FOO')('Event' 1002 1)</pre><p>The expression:</p><pre>      ⎕NQ Form1 1001 'Hello' 42</pre><p>would cause <tt>⎕DQ</tt> to invoke the function <tt>FOO</tt>, passing it the entire event message <tt>(#.Form1 1001 'Hello' 42)</tt> as its right argument. Similarly, the expression:</p><pre>      ⎕NQ 'Form1' 1002 23.59</pre><p>would cause <tt>⎕DQ</tt> to terminate with the array <tt>('Form1' 1002 23.59)</tt> as its result.</p><p><tt>⎕NQ</tt> can be used to generate events in one of three ways which affect the <b>context</b> in which the event is processed.</p><p>If it is used monadically as in the examples above, or with a left argument of 0, <tt>⎕NQ</tt> adds the event specified in its right argument onto the bottom of the event queue. The event is then processed by <tt>⎕DQ</tt> when it reaches the head of the queue. You can add events to the queue <b>prior</b> to calling <tt>⎕DQ</tt>, or from within a callback function which is itself called by <tt>⎕DQ</tt>. In either case, the context in which the event is finally processed may be completely different from the context in which the event was placed on the queue. When used in this way, the result of <tt>⎕NQ</tt> is always an empty character vector.</p><p>If you use <tt>⎕NQ</tt> with a left argument of 1, the event is processed there and then by <tt>⎕NQ</tt> itself. If there is a callback function attached to the event, <tt>⎕NQ</tt> invokes it directly. Thus like <tt>⎕DQ</tt>, <tt>⎕NQ</tt> can appear in the State Indicator <tt>⎕SI</tt> or <tt>)SI</tt>. This use of <tt>⎕NQ</tt> is used to generate an event for an object that is not currently included in a <tt>⎕DQ</tt>, and is the usual way of generating the special (non-user) events on the Printer and other objects. It is also used when you want to cause an event to occur <b>immediately</b> without waiting for any events already in the queue to be processed first. When used in this way, the result of <tt>⎕NQ</tt> is either an empty character vector, or the result of the callback function if one is attached.</p><p>If you use <tt>⎕NQ</tt> with a left argument of 2, APL immediately performs the default processing (if any) for the event, bypassing any callback function. This case of <tt>⎕NQ</tt> is often used <span class="Italic">within</span> a callback function to put the object into the state that it would otherwise be in when the callback terminated. When used in this way, the result of <tt>⎕NQ</tt> is 1. To avoid processing the event twice, the callback function should return 0.</p><p>The use of <tt>⎕NQ</tt> with a left argument of 2, is the same as calling the event as a method, and this is discussed in the next section.</p><p>A left argument of 4 is a special case that is used by an ActiveXControl or NetType object to generate an event in its host application. See Chapter 13 for details.</p></body>
</html>