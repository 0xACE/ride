<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><a name="Shared_Variable_Principles"></a>Shared Variable Principles</h2><p>Shared Variables are part of the APL standard, although strictly speaking as an optional facility. They provide a comprehensive mechanism for communicating between two APL workspaces, or between APL and a co-operating non-APL application. Despite some conflicts between Shared Variable concepts and DDE, this standard APL mechanism has overriding advantages as the basis for a DDE interface. The main benefit is that Shared Variables provide a <b>general</b> basis for developing communications using a variety of protocols, of which DDE is but a single example. Dyalog APL communications are not therefore designed for and limited to DDE, but can be extended to other protocols which are appropriate in different environments.</p><p>Most mainframe APL users will already be familiar with Shared Variables and will need no introduction to their concepts. New APL users, or those whose experience has been only of PC-based interpreters, may find the following introduction helpful.</p><h4><a name="Introduction"></a>Introduction</h4><p>It is easiest to consider Shared Variables between two APL workspaces. A Shared Variable is simply a variable that is common to and visible in two workspaces. Once a variable is shared, its value is the same in both workspaces. Communication is achieved by one workspace assigning a new value to the variable and then the other workspace referencing it. Although there is no explicit <b>send</b> or <b>receive</b>, it is perhaps easier to think of things in this way. When you assign a value to a shared variable, you are in effect transmitting it to your partner. When you reference a shared variable, you are in fact receiving it from your partner.</p><p>This discussion of shared variables will refer to the terms <b>set</b> and <b>use</b>. The term <b>set</b> means to assign a (new) value to a variable, i.e. its name appears to the left of an assignment arrow. The term <b>use</b> means to refer to the value of a variable, i.e. its name appears to the right of an assignment arrow.</p><h4><a name="Sharing"></a>Sharing a Variable</h4><p>Variables are shared using the system function <tt>⎕SVO</tt>. This is a dyadic function whose right argument specifies the name (or a matrix of names) of the variable, and whose left argument identifies the partner with whom the variable is to be shared. In mainframe APL, you identify the partner by its processor id. For example, the following statement means that you offer to share the variable <tt>X</tt> with processor 123.</p><pre>      123 ⎕SVO 'X'</pre><p>A single <tt>⎕SVO</tt> by one workspace is not however sufficient to make a connection. It is necessary that <b>both</b> partners make an offer to share the variable. Thus if you are process 345, your partner must complete the coupling by making an equivalent shared variable offer, e.g.</p><pre>      345 ⎕SVO 'X'</pre><p>The coupling process is symmetrical and there is no specific order in which offers must be made. However, there is a concept known as the <span class="Italic">degree of coupling</span> which is returned as the result of <tt>⎕SVO</tt>. The degree of coupling is simply a count of the number of processes which currently have the variable "on offer". When the first process offers to share the variable, its <tt>⎕SVO</tt> will return 1. When the second follows suit, its <tt>⎕SVO</tt> returns 2. The first process can tell when coupling is complete by calling <tt>⎕SVO</tt> monadically at a later point, as illustrated below.</p><table><tr><th>Process 345</th><th>Process 123</th></tr><tr><td class="DyalogPlain">      123 ⎕SVO 'X'</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">
1</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">      345 ⎕SVO 'X'</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">2</td></tr><tr><td class="DyalogPlain">      ⎕SVO 'X'</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">
2</td><td class="DyalogPlain"> </td></tr></table><p>In this example, both partners specified exactly whom they wished to share with. These are termed <b>specific offers</b>. It is also possible to make a <b>general offer</b>, which means that you offer to share a particular variable with <b>anyone</b>. Coupling can be established by any other processor that offers to share the same variable with you, but notice that the other processor must make a <b>specific offer</b> to couple with your general one. The rule is in fact, that sharing may be established by matching a specific offer with another specific offer, or by matching a specific offer with a general offer. Two general offers cannot establish a connection.</p><h4><a name="State_Vector"></a>The State Vector</h4><p>One of the interesting things about Shared Variables, is that both APL workspaces are equal partners. Either of them is allowed to change the value of a shared variable, thus communication is two way. In any communication of this sort, it is essential to have a mechanism to keep things in step. If not, it is possible for one partner to miss something or to receive the same message twice. In some applications this doesn't matter. For example, if one APL workspace is simply monitoring the current value of a particular currency, it does not matter that a second workspace doesn't see all of the fluctuations as they occur. It is important only that the latest value can be referenced when it is needed. Contrast this with a trading application in which the trading workspace registers each transaction with a second workspace which monitors and stores the transactions on a database. Clearly in this case it is essential that each and every transaction is properly communicated and recorded.</p><p>Synchronisation is provided by two system functions, <tt>⎕SVS</tt> and <tt>⎕SVC</tt>. <tt>⎕SVS</tt> reports the current value of a shared variable's <b>State Vector</b>. This provides information concerning the state of the variable from each partner's point of view. The second function, <tt>⎕SVC</tt>, allows you and your partner to specify interlocking that enforces the level of synchronisation required by your application.</p><p>Each shared variable has a <b>state vector</b> which indicates which partner has set a value of which the other is still ignorant, and which partner is aware of the current value. The current state of a shared variable is reported by the monadic system function <tt>⎕SVS</tt>. Its argument is the name of the shared variable. Its result is a 4-element Boolean vector which specifies the current state vector, i.e.</p><pre>      state ← ⎕SVS name</pre><p>The state vector will have one of the following values:</p><table><tr><td><tt>0 0 0 0</tt></td><td>The variable is not shared</td></tr><tr><td><tt>0 0 1 1</tt></td><td>Both partners know the current value</td></tr><tr><td><tt>1 0 1 0</tt></td><td>You have set the value, but your partner has yet to use it.</td></tr><tr><td><tt>0 1 0 1</tt></td><td>Your partner has set the variable but you have not yet used it.</td></tr></table><p>It may not be immediately apparent as to how the information provided by <tt>⎕SVS</tt> can be used. The answer, as we will see later, is that communications generates <b>events</b>. That is to say, when your partner sets a shared variable to a new value or references a value that you have set, an event is generated telling you that something has happened. <tt>⎕SVS</tt> is then used to determine what has happened (set or use) and, if you have several variables shared, which one of the variables has in some way changed state. A shared variable state change is thus the trigger that forces some kind of action out of the other process.</p><h4><a name="Access_Control"></a>Access Control</h4><p><tt>⎕SVS</tt> is not sufficient on its own to synchronise data transfer. For example, what if the two partners both set the shared variable to a different value at <b>exactly</b> the same point in time ?  This is the role of <tt>⎕SVC</tt> which actually assures data integrity (if required) by imposing access controls. Its purpose is to synchronise the order in which two applications <b>set</b> and <b>use</b> the value of a shared variable.</p><p>In simple terms, <tt>⎕SVC</tt> allows an application to inhibit its partner from setting a new value before it has read the current one, and/or to inhibit its partner from using a variable again before it has been reset.</p><p><tt>⎕SVC</tt> is a dyadic system function. Its right argument specifies the name of the shared variable; its left argument the access control vector, i.e.</p><pre>       access ⎕SVC name</pre><p>The access control vector is a 4-element Boolean vector whose elements specify access control as follows:</p><table><tr><td><tt>[1]</tt></td><td>1 means that you cannot set the variable until your partner has used it.</td></tr><tr><td><tt>[2]</tt></td><td>1 means that your partner cannot set the variable until you have used it.</td></tr><tr><td><tt>[3]</tt></td><td>1 means that you cannot use the variable until your partner has set it.</td></tr><tr><td><tt>[4]</tt></td><td>1 means that your partner cannot use the variable until you have set it.</td></tr></table><p>In principle, each of the two partners maintains its own copy of the access control vector using <tt>⎕SVC</tt>. Control is actually imposed by the <b>effective access control vector</b> which is the result of "ORing" the two individual ones. From your own point of view, the effective access control vector is:</p><pre>   (your ⎕SVC)  ∨  (your partner's ⎕SVC)[3 4 1 2]</pre><p>Whenever either of the partners attempts an operation (set or use) on a shared variable, the system consults its effective access control vector. If the vector indicates that the operation is currently permitted, it goes ahead. If however the vector indicates that the operation is currently inhibited, the operation is delayed until the situation changes.</p><p>For example, suppose that the effective access control vector is (1 0 0 1). This prevents either partner from setting the shared variable twice in a row, without an intervening use by the other. The purpose of this is to prevent loss of data. Suppose now that one workspace assigns the value 10 to the shared variable (which is called <tt>DATA</tt>), i.e.</p><p class="pagebreakafter"> </p><pre>      DATA ← 10</pre><p>Then, before the partner has referenced the new value it attempts to execute the statement:</p><pre>      DATA ← 20</pre><p>APL will <b>not</b> execute the statement. Instead it will wait (indefinitely if required) until the partner has received the first value (10). Only then will the second assignment be executed and processing continued. Effectively one workspace stops and waits for the other to catch up.</p><p>Similarly, suppose that the effective access control vector is (0 0 1 1). This means that neither partner can <b>use</b> the variable twice in succession without an intervening <b>set</b> by the other. This type of control is appropriate where each <b>set</b> corresponds to an individual transaction, and you want to prevent transactions from inadvertently being duplicated.</p><p>Suppose now that one workspace references the shared variable (which is called <tt>DATA</tt>), i.e.</p><pre>      TRANSACTION ← DATA</pre><p>Then, soon after, it executes the statement again, but without an intervening <b>set</b> by its partner, i.e.</p><pre>      TRANSACTION ← DATA</pre><p>This time, the reference to <tt>DATA</tt> is inhibited, and the workspace waits (indefinitely if necessary) until the partner has assigned a new value. Only then will the second reference be executed and processing continued. Again, one workspace stops and waits for the other.</p><p>The purpose of <tt>⎕SVC</tt> is to synchronise data transfer. It is particularly useful where timing considerations would otherwise cause data loss. However, an incorrect application which makes inappropriate use of <tt>⎕SVC</tt> may hang.</p><p>A second type of problem can occur during the development of an application that uses shared variables. If the program is interrupted by an error, an attempt to display the value of a shared variable counts as a "use" and, if inhibited, will hang. In applications that use interlocking, it is recommended that a shared variable is explicitly "used" by making an assignment to a temporary variable which can then be referenced freely.</p><p>This is the theory; we will now see how DDE, by its very nature, imposes certain limitations in practice.</p></body>
</html>