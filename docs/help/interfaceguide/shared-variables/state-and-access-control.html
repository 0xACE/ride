<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><a name="State_Access_Control"></a>State and Access Control</h2><p>Earlier, we have seen how shared variable state and access controls are used to ensure effective communication between two APL tasks. How do these concepts apply in the DDE environment when APL is using shared variables to communicate via DDE with both other APL workspaces, and with non-APL applications?</p><p>The initial state of a shared variable on the completion of sharing depends upon whether your variable is a server or a client. If it is a server, the initial state vector is (1 0 1 0) which means that you have set (and know) the value, but your partner has yet to use it. If the variable is acting as a client, the initial state vector is (0 1 0 1). This implies that your partner has set the value but you have yet to use it.</p><p>As your partner can be a non-APL application which does not share the concepts of <b>set</b> and <b>use</b>, it is necessary to define a rule or set of rules from which APL can reasonably infer such actions.</p><p>During a DDE conversation, the physical transfer of data from one application to another is achieved using DDE DATA messages. When a DATA message is sent, the receiving task normally returns an ACK (acknowledgement) message. APL uses the DATA and ACK messages to control Shared Variable access.</p><p>When an assignment is made to a shared variable, APL sends a DATA message to the second process. When it receives back an ACK message, APL infers that this means that the partner has <b>used</b> the variable. When APL receives a DATA message from the other process it infers that the partner has <b>set</b> the variable. However, it only responds with an ACK message when the new value of the variable is referenced by the workspace.</p><p>Let's see what this means if two APL workspaces are involved.</p><table><tr><th class="Left">Server Workspace</th><th class="Left">Client Workspace</th></tr><tr><th> </th><th> </th></tr><tr><td class="SubHeading">Make general offer</td><td class="SubHeading"> </td></tr><tr><td class="DyalogPlain">      X←42</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">      'DDE:' ⎕SVO 'X'</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">1</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">      ⎕SVS 'X'</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">0 0 0 0 ⍝ No partner</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">      ⎕SVC 'X'</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">0 0 0 0 ⍝ No access ctl</td><td class="DyalogPlain"> </td></tr><tr><th> </th><th> </th></tr><tr><td class="SubHeading"> </td><td class="SubHeading">Make specific offer</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">'DDE:DYALOG|SERVER'⎕SVO'X'</td></tr><tr><td> </td><td>&lt;--- initiate ---</td></tr><tr><td>ack ---&gt;</td><td> </td></tr><tr><td> </td><td>&lt;--- please advise on change </td></tr><tr><td>ack ---&gt;</td><td> </td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">2  ⍝ Offer accepted</td></tr><tr><td class="DyalogPlain">      ⎕SVS 'X'</td><td class="DyalogPlain">      ⎕SVS 'X'</td></tr><tr><td class="DyalogPlain">1 0 1 0⍝ I know, not he </td><td class="DyalogPlain">0 1 0 1⍝ He knows, I don't</td></tr><tr><td class="SubHeading"> </td><td class="SubHeading">Client requests data</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">      Y ← X</td></tr><tr><td class="DyalogPlain"> </td><td>&lt;--- req ---</td></tr><tr><td>--- data (42) ---&gt;</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain"> </td><td>&lt;--- ack ---</td></tr><tr><td class="DyalogPlain">      ⎕SVS 'X'</td><td class="DyalogPlain">      ⎕SVS 'X'</td></tr><tr><td class="DyalogPlain">0 0 1 1⍝ We both know</td><td class="DyalogPlain">0 0 1 1⍝ We both know</td></tr><tr><td class="SubHeading">Server changes data</td><td class="SubHeading"> </td></tr><tr><td class="DyalogPlain">      X ← 20</td><td class="DyalogPlain"> </td></tr><tr><td>--- data has changed --&gt;</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain"> </td><td>&lt;--- ack ---</td></tr><tr><td class="DyalogPlain">      ⎕SVS 'X'</td><td class="DyalogPlain">      ⎕SVS 'X'</td></tr><tr><td class="DyalogPlain">1 0 1 0⍝ I know, not he</td><td class="DyalogPlain">0 1 0 1⍝ He knows, I don't</td></tr><tr><td class="SubHeading"> </td><td class="SubHeading">Client requests data</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">      Y ← X</td></tr><tr><td class="DyalogPlain"> </td><td>&lt;--- req ---</td></tr><tr><td>--- data (20) ---&gt;</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain"> </td><td>&lt;--- ack ---</td></tr><tr><td class="DyalogPlain">      ⎕SVS 'X'</td><td class="DyalogPlain">      ⎕SVS 'X'</td></tr><tr><td class="DyalogPlain">0 0 1 1⍝ We both know</td><td class="DyalogPlain">0 0 1 1⍝ We both know</td></tr></table><p>As you can see, this has the desired effect, namely that an APL workspace sets the value of a shared variable by assignment to it and <b>uses</b> it by reference to it. The mechanism of using the DATA and ACK messages to imply <b>set</b> and <b>use</b> also works with non-APL applications which do not (in general) support these concepts.</p><p>Access control between two APL workspaces is imposed by each workspace acting independently. Whenever either workspace changes its <tt>⎕SVC</tt>, the information is transmitted to the other. Thus both workspaces maintain their own copy of the <b>effective</b> access control vector upons which to base decisions.</p><table><tr><th class="Left">Server Workspace</th><th class="Left">Client Workspace</th></tr><tr><td class="SubHeading">No access control</td><td class="SubHeading">No access control</td></tr><tr><td class="DyalogPlain">      ⎕SVC 'X'</td><td class="DyalogPlain">      ⎕SVC 'X'</td></tr><tr><td class="DyalogPlain">0 0 0 0 ⍝ No access ctl</td><td class="DyalogPlain">0 0 0 0 ⍝ No access ctl</td></tr><tr><td> </td><td>Client makes multiple requests for data</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">       Y←X</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">       Y←X</td></tr><tr><td>Server can set several times</td><td> </td></tr><tr><td class="DyalogPlain">      X←30</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">      X←40</td><td class="DyalogPlain"> </td></tr><tr><td class="SubHeading">Set access control</td><td class="SubHeading"> </td></tr><tr><td class="DyalogPlain">      1 0 0 1 ⎕SVC 'X'</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">--- change in ⎕SVC --&gt;</td><td class="DyalogPlain"> </td></tr><tr><td class="DyalogPlain">      ⎕SVC 'X'</td><td class="DyalogPlain">      ⎕SVC 'X'</td></tr><tr><td class="DyalogPlain"><pre class="Dyalog">1 0 0 1⍝ I cannot set
         until he has
         used; he cannot
         use untilI
         have set</pre></td><td class="DyalogPlain"><pre class="Dyalog">0 1 1 0⍝ He cannot set
         until I have
         used. I cannot
         use until he
         has set</pre></td></tr><tr><td class="SubHeading"> </td><td class="SubHeading">Client requests data</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">      Y ← X</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">&lt;--- req ---</td></tr><tr><td class="DyalogPlain"> </td><td>(hangs waiting for data)</td></tr><tr><td class="SubHeading">Server changes data</td><td class="SubHeading"> </td></tr><tr><td class="DyalogPlain">      X ← 30</td><td class="DyalogPlain"> </td></tr><tr><td>--- data (30) ---&gt;</td><td> </td></tr><tr><td> </td><td>&lt;--- ack ---</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">      Y⍝ data received</td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">30</td></tr><tr><td class="SubHeading">Server changes data</td><td class="SubHeading"> </td></tr><tr><td class="DyalogPlain">      X ← 40</td><td class="DyalogPlain"> </td></tr><tr><td>--- data has changed ---&gt;</td><td> </td></tr><tr><td> </td><td>&lt;--- ack ---</td></tr><tr><td>Server tries to change data again</td><td> </td></tr><tr><td class="DyalogPlain">      X ← 50</td><td class="DyalogPlain"> </td></tr><tr><td>--- data has changed ---&gt;</td><td> </td></tr><tr><td>(assignment hangs waiting for ack)</td><td> </td></tr><tr><td class="DyalogPlain"> </td><td class="DyalogPlain">      Y ← X⍝ use data</td></tr><tr><td> </td><td>&lt;--- req ---</td></tr><tr><td class="DyalogPlain">--- data (40) ---&gt;</td><td class="DyalogPlain"> </td></tr><tr><td> </td><td>&lt;--- ack ---</td></tr><tr><td class="DyalogPlain">      X⍝ assignment done</td><td class="DyalogPlain">      Y⍝ data received</td></tr><tr><td class="DyalogPlain">50</td><td class="DyalogPlain">40</td></tr></table><p>Where the second process is a non-APL application, the effective access control vector is maintained only by the APL task and access control can only be imposed by APL. At first sight, it may seem impossible for APL to affect another application in this way, and indeed there are severe limitations in what APL can achieve. Nevertheless, effective access control is possible in the case when it is desirable to inhibit the partner from <b>setting</b> the value twice without an intervening <b>use</b> by the APL task.</p><p>This is simply achieved by withholding the ACK message. Thus if APL receives a DATA message from its partner at a time when a <b>set</b> by the partner is inhibited, APL registers the new value but withholds the acknowledgement. Only when the inhibitor is removed will APL respond with an ACK. (Users with DDESPY will observe that this is actually implemented by APL re-transmitting the DATA message to itself when the inhibitor is removed).</p><p>Assuming that the second application waits for the acknowledgement before proceeding, this will cause the desired synchronisation. Naturally, this cannot be entirely guaranteed because APL has no <b>direct</b> control over a non-APL program. Indeed, when an application transmits a DATA message, it can include a flag to indicate that an acknowledgement is neither expected nor required. In these circumstances, APL is powerless to impose any access control.</p><p>Note that APL does not (and cannot) have any control over successive internal references to the data by a non-APL application.</p><p>The rule for establishing your partner's initial <tt>⎕SVC</tt> is as follows :</p><ul><li value="1">If the DDE link is a <b>warm</b> link, your partner's <tt>⎕SVC</tt> is initially (0 0 0 0).</li><li value="2">If the DDE link is instead a <b>hot</b> link, your partner's <tt>⎕SVC</tt> is initially (1 0 0 1).</li></ul><p>This works in practice as follows :</p><h4>Server = APL, Client = APL</h4><p>You made a general offer which has been accepted by another APL workspace, e.g.</p><pre>      'DDE:' ⎕SVO 'DATA'</pre><p>Two APL tasks always use a warm DDE link. Therefore, initially, both <tt>⎕SVC</tt>s are (0 0 0 0). Control is (optionally) imposed by both partners subsequently setting <tt>⎕SVC</tt>.</p><h4 class="ExampleNewPage">Server = APL, Client = another application</h4><p>You made a general offer which has been accepted by another application, e.g.</p><pre>      'DDE:' ⎕SVO 'DATA'</pre><p>The client application establishes the strength of the link (warm or hot). If it is a warm link, the initial value of the client's <tt>⎕SVC</tt> is (0 0 0 0) and, as the client has no means to change it itself, control may only be imposed by the server APL task. If the client establishes a hot link, its initial <tt>⎕SVC</tt> is (1 0 0 1). As it has no means to change it, and as the APL server task cannot (by definition) change it, the client's <tt>⎕SVC</tt> retains this setting for the duration of the conversation. (1 0 0 1) means that both partners are inhibited from setting the value of the shared variable twice in a row without an intervening use (or set) by the other. Given that the other application has requested a hot link (give me the value every time it changes) it is reasonable to assume that the application does not want to miss any values and will happily accept new data every time it is changed.</p><h4>Server = another application, Client = APL</h4><p>You made a <b>specific offer</b> to another application, e.g.</p><pre>      'DDE:EXCEL|SHEET1' ⎕SVO 'DATA R1C1:R3C4'</pre><p>In this case, APL as the client will request a warm DDE link. If the server fails to agree to this request, APL will ask for the current data value and, whether or not the server responds, will not establish a permanent link. Thus the only possibility for a permanent connection is a warm link. This in turn means that the server's <tt>⎕SVC</tt> will be (0 0 0 0). Furthermore, as the server has no means to change it, it's <tt>⎕SVC</tt> will remain (0 0 0 0) for the duration of the conversation. Control is therefore imposed solely by APL.</p><h4><a name="Terminating"></a>Terminating a Conversation</h4><p>A DDE conversation is terminated by "un-sharing" the variable. This can be done explicitly using <tt>⎕EX</tt> or <tt>⎕SVR</tt>. It is also done automatically when you exit a function in which a shared variable is localised.</p></body>
</html>