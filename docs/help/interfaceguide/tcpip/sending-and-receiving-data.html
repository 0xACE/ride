<!doctype html>
<html>
<head><meta charset="utf-8"><title></title><link rel="stylesheet" href="../../../help.css"></head>
<body><h2><a name="Sending_Receiving"></a>Sending and Receiving Data</h2><p>Once your TCPSocket object is connected, you can send and receive data. It makes no difference whether it was originally a server or a client; the mechanisms for data transfer are the same.</p><p>The <span class="Italic">type</span> of data that you can send and receive is defined by the Style property which was established when you created the TCPSocket object. The default Style is <tt>'Char'</tt> which allows you to send and receive character vectors. Conversion to and from your <tt>⎕AV</tt> is performed automatically.</p><p>If you choose to set Style to <tt>'Raw'</tt>, you can send and receive data as integer vectors whose values are in the range -127 to 255. This allows you to avoid any character translation.</p><p>If you set Style to <tt>'APL'</tt>, you may transmit and receive arbitrary arrays, including arrays that contain <tt>⎕OR</tt>’s of namespaces.  Furthermore, however the data is actually fragmented by TCP/IP, an array transmitted in this way will appear to be sent and received in single atomic operation. Data buffering is handled automatically by APL itself. Style <tt>'APL'</tt> is normally only appropriate for communicating between two Dyalog APL sessions. Note however, that there is no mechanism to ensure that both ends of the connection use the same Style.</p><p>To send data, you execute the TCPSend method. For example, the following expression will transmit the string "Hello World" to the remote task connected to the TCPSocket object <tt>S0</tt>:</p><pre>      2 ⎕NQ'S0' 'TCPSend' 'Hello World'</pre><p>To receive data, you must attach a callback function to the TCPRecv event. Note that for a Stream connection you are not guaranteed to receive a complete message as transmitted by the sender. Instead, the original message may be received as separate packets or several messages may be received as a single packet. This means that you must perform your own buffering and you must implement a specific protocol to recognise message boundaries.</p><h4><a name="Output_Buffering"></a>Output Buffering</h4><p>When you use TCPSend to transmit a block of data, APL copies the data into a buffer that it allocates <span class="Italic">outside</span> your workspace from Windows memory. APL then asks TCP/IP to send it.</p><p>However, the amount of data that can be transmitted in one go is limited by the size of various TCP/IP buffers and the speed of the network. Unless the block is very small, the data must be split up and transmitted bit by bit in pieces. This process, which is handled by APL in the background, continues until the entire data block has been transmitted. It could be several seconds or even minutes after you execute TCPSend before the entire block of data has been sent from your PC.</p><p>If in the meantime you call TCPSend again, APL will allocate a second buffer in Windows memory and will only try to send the second block of data when all of the first block has been transmitted.</p><p>If you call TCPSend repeatedly, APL will allocate as many buffers as are required. However, if you attempt to send too much data too quickly, this mechanism will fail if there is insufficient Windows memory or disk space to hold them.</p><p>If you need to transmit a very large amount of data, you should break it up into chunks and send them one by one. Having sent the first chunk, you can tell when the system is ready for the next one using the TCPReady event. This event is reported when the TCP/IP buffers are free <span class="Italic">and</span> when there is no data waiting to be sent in the internal APL buffers. You should therefore attach a callback, whose job is to send the next chunk of data, to this event.</p><p>Note that a further level of buffering occurs in the <span class="Italic">client</span> if the Style property of the TCPSocket is set to <tt>'APL'</tt>. This is done to prevent the partial reception of an APL array which would represent an invalid data object.</p></body>
</html>